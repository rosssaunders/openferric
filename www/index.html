<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTC Options Vol Terminal</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dockview-core@4.3.1/dist/styles/dockview.css">
  <style>
    :root {
      --bg: #070a0f;
      --panel: #11161f;
      --border: #263241;
      --fg: #d8e0ea;
      --muted: #8ea1b8;
      --accent: #2fb2ff;
      --accent2: #19d8a8;
      --danger: #ff7a7a;
      --warn: #ffb347;
      --mono: "JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, monospace;
      --sans: "IBM Plex Sans", "Segoe UI", Helvetica, Arial, sans-serif;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      color: var(--fg);
      font-family: var(--sans);
      background:
        radial-gradient(1000px 700px at 12% -20%, #15314f 0%, rgba(21,49,79,0) 60%),
        radial-gradient(900px 650px at 100% 0%, #0f2d25 0%, rgba(15,45,37,0) 58%),
        linear-gradient(180deg, #06080c 0%, #070a0f 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ---- Header ---- */
    .header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 8px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(17,22,31,0.85);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      white-space: nowrap;
    }
    .header-spot {
      font-family: var(--mono);
      font-size: 16px;
      color: var(--accent2);
      min-width: 110px;
    }
    .sparkline-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }
    .sparkline-wrap svg { display: block; }
    .status-pill {
      font-size: 11px;
      font-family: var(--mono);
      padding: 3px 10px;
      border-radius: 20px;
      border: 1px solid var(--border);
      white-space: nowrap;
    }
    .status-pill.connected { color: var(--accent2); border-color: var(--accent2); }
    .status-pill.connecting { color: var(--warn); border-color: var(--warn); }
    .status-pill.disconnected { color: var(--danger); border-color: var(--danger); }

    /* ---- Dockview panel content ---- */
    .dock-content {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      padding: 6px 8px;
      background: color-mix(in srgb, var(--panel) 92%, black);
    }
    .panel-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-shrink: 0;
    }
    .panel-title {
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .chart-area {
      flex: 1;
      min-height: 0;
    }

    /* ---- Toolbar ---- */
    .toolbar {
      display: flex;
      gap: 4px;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
    }
    select, .tab-btn {
      background: #0d141d;
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: var(--mono);
      font-size: 11px;
      cursor: pointer;
    }
    .tab-btn.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    /* ---- Metrics table ---- */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 3px 8px;
      font-size: 11px;
      margin-bottom: 6px;
    }
    .metrics-grid .k { color: var(--muted); }
    .metrics-grid .v { text-align: right; font-family: var(--mono); }
    .tbl-wrap {
      flex: 1;
      overflow: auto;
      min-height: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    th, td {
      padding: 2px 0;
      border-bottom: 1px solid rgba(142,161,184,0.12);
      text-align: right;
      font-family: var(--mono);
    }
    th:first-child, td:first-child {
      text-align: left;
      font-family: var(--sans);
      color: var(--muted);
    }
    th { color: var(--muted); font-weight: 500; }

    /* ---- Mispricing Scanner ---- */
    .scanner-wrap {
      display: flex;
      gap: 6px;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    .scanner-heatmap {
      flex: 1.2;
      min-height: 0;
    }
    .scanner-table-wrap {
      flex: 1;
      overflow: auto;
      min-height: 0;
    }
    .scanner-table-wrap table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    .scanner-table-wrap th {
      position: sticky;
      top: 0;
      background: var(--panel);
      z-index: 1;
    }
    .scanner-table-wrap td { white-space: nowrap; }
    .edge-buy { color: var(--accent2); }
    .edge-sell { color: var(--danger); }
    .edge-strong { font-weight: 700; }
    .edge-actionable { background: rgba(25,216,168,0.08); }
    .edge-actionable.sell { background: rgba(255,122,122,0.08); }

    /* ---- Dockview theme overrides ---- */
    .dockview-theme-abyss {
      --dv-group-view-background-color: var(--panel);
      --dv-tabs-and-actions-container-background-color: color-mix(in srgb, var(--panel) 70%, black);
      --dv-separator-border: var(--border);
      --dv-activegroup-visiblepanel-tab-background-color: var(--panel);
      --dv-activegroup-hiddenpanel-tab-background-color: transparent;
      --dv-inactivegroup-visiblepanel-tab-background-color: color-mix(in srgb, var(--panel) 50%, black);
      --dv-inactivegroup-hiddenpanel-tab-background-color: transparent;
      --dv-activegroup-visiblepanel-tab-color: var(--fg);
      --dv-activegroup-hiddenpanel-tab-color: var(--muted);
      --dv-inactivegroup-visiblepanel-tab-color: var(--muted);
      --dv-inactivegroup-hiddenpanel-tab-color: var(--muted);
      --dv-tab-divider-color: var(--border);
      --dv-drag-over-background-color: rgba(47,178,255,0.1);
      --dv-drag-over-border-color: var(--accent);
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "dockview-core": "https://esm.sh/dockview-core@4.3.1"
    }
  }
  </script>
</head>
<body>
  <!-- ===== Header ===== -->
  <div class="header">
    <div class="header-title">BTC Options Vol Terminal</div>
    <div class="header-spot" id="hdr-spot">--</div>
    <div class="sparkline-wrap">
      spot
      <svg id="spark-spot" width="80" height="22" viewBox="0 0 80 22"></svg>
    </div>
    <div class="sparkline-wrap">
      ATM vol
      <svg id="spark-vol" width="80" height="22" viewBox="0 0 80 22"></svg>
    </div>
    <div class="toolbar" style="margin-left: auto;">
      <label for="model-select">model</label>
      <select id="model-select">
        <option value="svi" selected>SVI</option>
        <option value="sabr">SABR</option>
        <option value="vv">Vanna-Volga</option>
      </select>
      <span id="calib-time" style="font-family:var(--mono);font-size:10px;color:var(--muted)"></span>
    </div>
    <button id="reset-layout" class="tab-btn" title="Reset panel layout to default">Reset Layout</button>
    <div class="status-pill connecting" id="status-pill">connecting...</div>
  </div>

  <!-- ===== Dockview Container ===== -->
  <div id="dockview" class="dockview-theme-abyss" style="height: calc(100vh - 44px);"></div>

  <script type="module">
    import { DockviewComponent } from 'dockview-core';

    // =====================================================================
    //  WASM loader (required — no JS fallback)
    // =====================================================================
    let wasmReady = false;
    let wasm = null;
    const wasmPromise = (async () => {
      try {
        const mod = await import('./pkg/openferric.js');
        await mod.default();
        wasm = mod;
        wasmReady = true;
        console.log('[wasm] loaded');
      } catch (e) {
        console.error('[wasm] FATAL: load failed:', e.message);
        document.body.innerHTML = '<div style="color:#ff7a7a;padding:40px;font-size:18px">'
          + 'WASM module failed to load. Run: <code>wasm-pack build --target web --features wasm</code></div>';
      }
    })();

    // =====================================================================
    //  Plotly common layout helpers
    // =====================================================================
    const darkLayout = {
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      font: { color: '#d8e0ea', family: 'IBM Plex Sans, sans-serif', size: 10 },
    };
    const axisStyle = { gridcolor: '#1e2d3d', zerolinecolor: '#1e2d3d', color: '#8ea1b8' };
    const pFmt = new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 });
    const pFmt1 = new Intl.NumberFormat('en-US', { maximumFractionDigits: 1 });

    // =====================================================================
    //  Deribit protocol helpers
    // =====================================================================
    const MONTHS = { JAN:1,FEB:2,MAR:3,APR:4,MAY:5,JUN:6,JUL:7,AUG:8,SEP:9,OCT:10,NOV:11,DEC:12 };

    function parseDeribitExpiry(code) {
      if (code.length !== 7) return null;
      const day = parseInt(code.slice(0, 2), 10);
      const mon = MONTHS[code.slice(2, 5)];
      const yr = 2000 + parseInt(code.slice(5, 7), 10);
      if (!mon || isNaN(day) || isNaN(yr)) return null;
      return new Date(Date.UTC(yr, mon - 1, day, 8, 0, 0));
    }

    function parseInstrumentName(name) {
      const p = name.split('-');
      if (p.length !== 4) return null;
      const expDate = parseDeribitExpiry(p[1]);
      if (!expDate) return null;
      const strike = parseFloat(p[2]);
      if (isNaN(strike)) return null;
      const isCall = p[3] === 'C';
      if (p[3] !== 'C' && p[3] !== 'P') return null;
      return { expiry: p[1], expiryDate: expDate, strike, isCall };
    }

    function normalizeIv(raw) {
      if (!isFinite(raw) || raw <= 0) return NaN;
      return raw > 3.0 ? raw / 100.0 : raw;
    }

    // =====================================================================
    //  Market State
    // =====================================================================
    const chain = new Map(); // instrument_name -> quote object
    let spotPrice = 0;
    let dirty = false;
    let tickCount = 0;
    let tickWindowStart = performance.now();
    let ticksPerSec = 0;

    // Previous IV snapshot for vol-change heatmap
    let prevIvMap = new Map(); // "expiry|strike" -> iv

    // Session baseline for surface diff
    let baselineSurface = null;

    // Circular buffers for sparklines
    const SPARK_LEN = 100;
    const spotHistory = [];
    const atmVolHistory = [];

    // Spot log returns for realized vol
    const spotLogReturns = [];

    function noteQuote(name, q) {
      chain.set(name, q);
      dirty = true;
      tickCount++;
    }

    function refreshTps() {
      const elapsed = (performance.now() - tickWindowStart) / 1000;
      if (elapsed >= 1.0) {
        ticksPerSec = tickCount / elapsed;
        tickCount = 0;
        tickWindowStart = performance.now();
      }
    }

    // =====================================================================
    //  Active model selection
    // =====================================================================
    let activeModel = 'svi'; // 'svi' | 'sabr' | 'vv'

    document.getElementById('model-select').addEventListener('change', (e) => {
      activeModel = e.target.value;
      dirty = true;
      baselineSurface = null; // reset baseline on model switch
      scheduleCalibration();
    });

    // =====================================================================
    //  WASM batch helpers — all math runs in Rust
    // =====================================================================
    const MODEL_SVI = 0, MODEL_SABR = 1, MODEL_VV = 2;

    function modelTypeCode(mt) {
      if (mt === 'svi') return MODEL_SVI;
      if (mt === 'sabr') return MODEL_SABR;
      if (mt === 'vv') return MODEL_VV;
      return 255;
    }

    function modelParamArray(sl) {
      const mt = sl.modelType, p = sl.params;
      if (mt === 'svi') return [p.a, p.b, p.rho, p.m, p.sigma];
      if (mt === 'sabr') return [p.alpha, p.beta, p.rho, p.nu];
      if (mt === 'vv') return [p.atmVol, p.rr25, p.bf25];
      return [];
    }

    // Pack calibratedSlices into flat arrays for WASM batch functions.
    // Returns { headers: Float64Array, params: Float64Array }.
    function packSliceArrays(slices) {
      const headerArr = [];
      const paramArr = [];
      for (const sl of slices) {
        const code = modelTypeCode(sl.modelType);
        const offset = paramArr.length;
        headerArr.push(code, sl.T, sl.forward, offset);
        paramArr.push(...modelParamArray(sl));
      }
      return {
        headers: new Float64Array(headerArr),
        params: new Float64Array(paramArr),
      };
    }

    // =====================================================================
    //  Calibration (per-expiry, model-aware)
    // =====================================================================
    let calibrationScheduled = false;
    let lastCalibTime = 0;
    let calibTimeUs = 0;
    let calibratedSlices = []; // sorted by T
    let activeExpiry = '';
    let activeGreek = 'delta';

    function scheduleCalibration() {
      if (calibrationScheduled) return;
      calibrationScheduled = true;
      setTimeout(runCalibration, 1000);
    }

    function runCalibration() {
      calibrationScheduled = false;
      if (!dirty) return;
      if (!wasmReady) { dirty = true; setTimeout(runCalibration, 100); return; }
      dirty = false;

      const now = Date.now();
      const nowSec = now / 1000;
      const t0 = performance.now();
      const model = activeModel;

      // Group by expiry code
      const grouped = new Map();
      for (const [, q] of chain) {
        if (q.mark_iv <= 0 || q.strike <= 0) continue;
        const key = q.expiryCode;
        if (!grouped.has(key)) grouped.set(key, []);
        grouped.get(key).push(q);
      }

      const slices = [];
      for (const [expiryCode, quotes] of grouped) {
        if (quotes.length < 5) continue;

        const expiryDate = parseDeribitExpiry(expiryCode);
        if (!expiryDate) continue;
        const T = (expiryDate.getTime() / 1000 - nowSec) / (365.25 * 24 * 3600);
        if (T <= 0) continue;

        const forward = quotes.reduce((s, q) => s + q.underlying_price, 0) / quotes.length;
        if (!isFinite(forward) || forward <= 0) continue;

        // Build per-quote data, filtering illiquid/suspect points
        const qByKRaw = [];
        for (const q of quotes) {
          const k = Math.log(q.strike / forward);
          qByKRaw.push({ k, q });
        }

        // Filter: require positive mark_iv, positive open interest or bid_iv > 0
        // For short expiries (< 7d), also clip extreme wings where bid-ask is very wide
        const qByK = qByKRaw.filter(({ k, q }) => {
          if (!q.mark_iv || q.mark_iv <= 0) return false;
          // Remove points with zero bid (no real market)
          if (q.bid_iv !== undefined && q.bid_iv <= 0 && q.open_interest <= 0) return false;
          // Remove extreme wings with wide bid-ask spread (> 50% of mid)
          if (q.bid_iv > 0 && q.ask_iv > 0) {
            const spread = q.ask_iv - q.bid_iv;
            const mid = (q.ask_iv + q.bid_iv) / 2;
            if (mid > 0 && spread / mid > 0.5) return false;
          }
          // For very short expiries, restrict to near-ATM strikes
          if (T < 7/365 && Math.abs(k) > 0.15) return false;
          if (T < 30/365 && Math.abs(k) > 0.5) return false;
          return true;
        });

        // If filtering removed too many points, fall back to raw (need at least 3 for SVI)
        if (qByK.length < 3) {
          qByK.length = 0;
          for (const item of qByKRaw) {
            if (item.q.mark_iv > 0) qByK.push(item);
          }
        }

        // ATM vol (closest to k=0)
        let atmVol = 0;
        let minAbsK = Infinity;
        for (const { k, q } of qByK) {
          if (Math.abs(k) < minAbsK) {
            minAbsK = Math.abs(k);
            atmVol = q.mark_iv;
          }
        }

        // ---- Model-specific calibration ----
        let params, modelType;

        if (model === 'sabr') {
          // SABR: fit in strike/vol space
          modelType = 'sabr';
          const strikes = qByK.map(({ q }) => q.strike);
          const vols = qByK.map(({ q }) => q.mark_iv);

          const strikesArr = new Float64Array(strikes);
          const volsArr = new Float64Array(vols);
          const wp = wasm.fit_sabr_wasm(forward, strikesArr, volsArr, T, 0.5);
          params = { alpha: wp.alpha, beta: wp.beta, rho: wp.rho, nu: wp.nu };
        } else if (model === 'vv') {
          // Vanna-Volga: derive from ATM + 25d RR/BF
          modelType = 'vv';
          // Sort by moneyness to find 25-delta wing vols
          const sorted = [...qByK].sort((a, b) => a.k - b.k);
          // Approximate: put wing ~ 25th percentile, call wing ~ 75th percentile
          const n = sorted.length;
          const putIdx = Math.max(0, Math.round(n * 0.15));
          const callIdx = Math.min(n - 1, Math.round(n * 0.85));
          const putVol = sorted[putIdx].q.mark_iv;
          const callVol = sorted[callIdx].q.mark_iv;
          const rr25 = callVol - putVol;
          const bf25 = 0.5 * (callVol + putVol) - atmVol;
          params = { atmVol, rr25, bf25 };
        } else {
          // SVI (default) — fit in implied-variance space (sigma^2), then convert back
          // This avoids numerical issues with tiny total variance at short expiries.
          modelType = 'svi';
          const points = [];
          // Weight points by open interest: repeat high-OI points more
          const maxOi = Math.max(1, ...qByK.map(({ q }) => q.open_interest || 0));
          for (const { k, q } of qByK) {
            // Use implied variance (sigma^2) NOT total variance (sigma^2*T) for stable numerics
            const iv2 = q.mark_iv * q.mark_iv;
            const oi = q.open_interest || 0;
            const reps = 1 + Math.floor((oi / maxOi) * 4);
            for (let r = 0; r < reps; r++) {
              points.push(k, iv2);
            }
          }
          const atmIv2 = Math.max(atmVol * atmVol, 1e-4);

          const flat = new Float64Array(points);
          const wp = wasm.calibrate_svi_wasm(flat, atmIv2*0.5, atmIv2*1.5, -0.1, 0.0, 0.15, 3000, 0.002);
          // Convert back: SVI was fit to sigma^2, so params.a etc are in sigma^2 space
          // To get total variance: w(k) = T * svi(k), so just scale a by T
          params = { a: wp.a * T, b: wp.b * T, rho: wp.rho, m: wp.m, sigma: wp.sigma };
        }

        // Compute fitted IV, RMSE, skew, kurtosis via WASM
        const diagKs = new Float64Array(qByK.map(({ k }) => k));
        const diagIvs = new Float64Array(qByK.map(({ q }) => q.mark_iv * 100));
        const diagStrikes = new Float64Array(qByK.map(({ q }) => q.strike));
        const diagParams = new Float64Array(modelParamArray({ modelType, params }));
        const diag = wasm.slice_fit_diagnostics(
          modelTypeCode(modelType), diagParams, T, forward, diagKs, diagIvs, diagStrikes
        );
        const rmse = diag[0];
        const skew = diag[1];
        const kurtProxy = diag[2];
        const slicePoints = [];
        for (let j = 0; j < qByK.length; j++) {
          const { q } = qByK[j];
          slicePoints.push({
            strike: q.strike,
            market_iv: q.mark_iv * 100,
            fitted_iv: diag[3 + j],
            bid_iv: (q.bid_iv || 0) * 100,
            ask_iv: (q.ask_iv || 0) * 100,
          });
        }
        slicePoints.sort((a, b) => a.strike - b.strike);

        slices.push({
          expiryCode,
          expiryLabel: expiryCode,
          T,
          params,
          modelType,
          rmse,
          n: qByK.length,
          atmVol: atmVol * 100,
          points: slicePoints,
          forward,
          skew,
          kurtProxy,
        });
      }

      slices.sort((a, b) => a.T - b.T);
      calibratedSlices = slices;

      calibTimeUs = Math.round((performance.now() - t0) * 1000);

      // Update surface title
      const modelNames = { svi: 'SVI', sabr: 'SABR', vv: 'Vanna-Volga' };
      if (panels.surface && panels.surface.titleEl) {
        panels.surface.titleEl.textContent =
          `3D Vol Surface (${modelNames[model] || model} fit + market)`;
      }

      // Save previous IVs for heatmap diff
      const newIvMap = new Map();
      for (const sl of slices) {
        for (const pt of sl.points) {
          newIvMap.set(sl.expiryCode + '|' + pt.strike, pt.market_iv);
        }
      }

      // If first calibration, set baseline
      if (!baselineSurface) {
        baselineSurface = slices.map(s => ({
          expiryCode: s.expiryCode,
          T: s.T,
          forward: s.forward,
          modelType: s.modelType,
          params: { ...s.params },
        }));
      }

      // Update sparklines
      if (spotPrice > 0) {
        if (spotHistory.length > 0) {
          const prevSpot = spotHistory[spotHistory.length - 1];
          if (prevSpot > 0) {
            spotLogReturns.push(Math.log(spotPrice / prevSpot));
            if (spotLogReturns.length > 500) spotLogReturns.shift();
          }
        }
        spotHistory.push(spotPrice);
        if (spotHistory.length > SPARK_LEN) spotHistory.shift();
      }
      const globalAtm = slices.length > 0 ? slices[0].atmVol : NaN;
      if (isFinite(globalAtm)) {
        atmVolHistory.push(globalAtm);
        if (atmVolHistory.length > SPARK_LEN) atmVolHistory.shift();
      }

      prevIvMap = newIvMap;

      // Render everything
      requestAnimationFrame(() => {
        renderAll();
      });
    }

    // (All math functions removed — running in Rust/WASM via batch calls)

    // =====================================================================
    //  Sparkline SVG renderer
    // =====================================================================
    function renderSparkline(svgEl, data, color) {
      if (data.length < 2) { svgEl.innerHTML = ''; return; }
      const w = 80, h = 22, pad = 2;
      let min = Infinity, max = -Infinity;
      for (const v of data) {
        if (v < min) min = v;
        if (v > max) max = v;
      }
      if (max - min < 1e-10) { max = min + 1; }
      const pts = data.map((v, i) => {
        const x = pad + (i / (data.length - 1)) * (w - 2 * pad);
        const y = h - pad - ((v - min) / (max - min)) * (h - 2 * pad);
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).join(' ');
      svgEl.innerHTML = `<polyline points="${pts}" fill="none" stroke="${color}" stroke-width="1.2" stroke-linejoin="round"/>`;
    }

    // =====================================================================
    //  Realized Vol (WASM)
    // =====================================================================
    function computeRealizedVol() {
      if (spotLogReturns.length < 2 || !wasmReady) return NaN;
      // ~1 observation per second (1s calibration interval), ~86400 sec/day, ~365.25 days
      const obsPerYear = 1 * 86400 * 365.25;
      return wasm.realized_vol(new Float64Array(spotLogReturns), obsPerYear);
    }

    // =====================================================================
    //  Panel Component Classes (Dockview vanilla API)
    // =====================================================================
    const panels = {};

    class SurfacePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">3D Vol Surface (SVI fit + market)</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.titleEl = this._el.querySelector('.panel-title');
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.surface = this;
        surfaceInitialized = false;
        zoomTarget = null;
        zoomCurrent = null;
        if (zoomRafId) { cancelAnimationFrame(zoomRafId); zoomRafId = null; }
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.surface;
      }
    }

    class VolChangePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">IV Change Heatmap</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.volchange = this;
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.volchange;
      }
    }

    class SmilePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Smile Slice</div>'
          + '<div class="toolbar">'
          + '<label>expiry</label>'
          + '<select class="expiry-select"></select>'
          + '</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.expirySelect = this._el.querySelector('.expiry-select');
        panels.smile = this;
        this.expirySelect.addEventListener('change', (e) => {
          activeExpiry = e.target.value;
          renderSmile();
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.smile;
      }
    }

    class GreeksPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Greeks Heatmap</div>'
          + '<div class="toolbar greeks-tabs">'
          + '<button class="tab-btn active" data-greek="delta">Delta</button>'
          + '<button class="tab-btn" data-greek="gamma">Gamma</button>'
          + '<button class="tab-btn" data-greek="vega">Vega</button>'
          + '<button class="tab-btn" data-greek="theta">Theta</button>'
          + '</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.tabContainer = this._el.querySelector('.greeks-tabs');
        panels.greeks = this;
        this.tabContainer.addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn');
          if (!btn) return;
          this.tabContainer.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          activeGreek = btn.dataset.greek;
          renderGreeks();
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.greeks;
      }
    }

    class TermPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Term Structure (ATM + RR25 + BF25)</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.term = this;
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.term;
      }
    }

    class MetricsPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Metrics &amp; Skew</div>'
          + '</div>'
          + '<div class="metrics-grid">'
          + '<div class="k">spot</div><div class="v m-spot">--</div>'
          + '<div class="k">options</div><div class="v m-options">--</div>'
          + '<div class="k">expiries</div><div class="v m-expiries">--</div>'
          + '<div class="k">ticks/sec</div><div class="v m-tps">--</div>'
          + '<div class="k">calib (us)</div><div class="v m-calib">--</div>'
          + '<div class="k">realized vol</div><div class="v m-rvol">--</div>'
          + '</div>'
          + '<div class="tbl-wrap">'
          + '<table>'
          + '<thead><tr><th>expiry</th><th>ATM</th><th>RMSE</th><th>skew</th><th>kurt</th><th>RR25</th><th>BF25</th><th>n</th></tr></thead>'
          + '<tbody></tbody>'
          + '</table>'
          + '</div>';
        this.mSpot = this._el.querySelector('.m-spot');
        this.mOptions = this._el.querySelector('.m-options');
        this.mExpiries = this._el.querySelector('.m-expiries');
        this.mTps = this._el.querySelector('.m-tps');
        this.mCalib = this._el.querySelector('.m-calib');
        this.mRvol = this._el.querySelector('.m-rvol');
        this.skewTbody = this._el.querySelector('tbody');
        panels.metrics = this;
      }
      dispose() { delete panels.metrics; }
    }

    class ScannerPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Mispricing Scanner</div>'
          + '<div class="toolbar">'
          + '<label>min edge</label>'
          + '<select class="edge-threshold">'
          + '<option value="0.5">0.5 vol</option>'
          + '<option value="1.0" selected>1.0 vol</option>'
          + '<option value="2.0">2.0 vol</option>'
          + '<option value="5.0">5.0 vol</option>'
          + '</select>'
          + '<label>side</label>'
          + '<select class="edge-side">'
          + '<option value="all" selected>all</option>'
          + '<option value="buy">buy only</option>'
          + '<option value="sell">sell only</option>'
          + '</select>'
          + '</div>'
          + '</div>'
          + '<div class="scanner-wrap">'
          + '<div class="scanner-heatmap"></div>'
          + '<div class="scanner-table-wrap">'
          + '<table>'
          + '<thead><tr>'
          + '<th>expiry</th><th>strike</th><th>C/P</th>'
          + '<th>mkt IV</th><th>mdl IV</th><th>IV edge</th>'
          + '<th>bid</th><th>ask</th><th>mid</th><th>theo</th>'
          + '<th>$ edge</th><th>signal</th>'
          + '</tr></thead>'
          + '<tbody></tbody>'
          + '</table>'
          + '</div>'
          + '</div>';
        this.heatmapDiv = this._el.querySelector('.scanner-heatmap');
        this.edgeTbody = this._el.querySelector('.scanner-table-wrap tbody');
        panels.scanner = this;
        this._el.querySelector('.edge-threshold').addEventListener('change', (e) => {
          edgeThreshold = parseFloat(e.target.value);
          renderScanner();
        });
        this._el.querySelector('.edge-side').addEventListener('change', (e) => {
          edgeSideFilter = e.target.value;
          renderScanner();
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.heatmapDiv && this.heatmapDiv.data) Plotly.Plots.resize(this.heatmapDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.scanner;
      }
    }

    // =====================================================================
    //  Per-frame WASM cache (computed once, shared across renderers)
    // =====================================================================
    let frameCache = null;

    function computeFrameCache() {
      if (calibratedSlices.length === 0 || !wasmReady) {
        frameCache = null;
        return;
      }
      const packed = packSliceArrays(calibratedSlices);
      const d25 = wasm.find_25d_strikes_batch(packed.headers, packed.params);
      const atmIv = wasm.iv_grid(packed.headers, packed.params, new Float64Array([0]));
      frameCache = { packed, d25, atmIv };
    }

    // =====================================================================
    //  Tiered rendering — expensive panels update less often
    // =====================================================================
    let renderCycle = 0;

    function renderAll() {
      renderCycle++;
      refreshTps();
      computeFrameCache();

      // Every cycle: cheap DOM-only updates
      renderHeader();
      renderMetrics();

      // Every cycle: lightweight 2D charts
      renderSmile();
      renderTerm();

      // Every 2nd cycle: medium-cost panels
      if (renderCycle % 2 === 0) {
        renderVolChange();
        renderGreeks();
      }

      // Every 3rd cycle: expensive panels
      if (renderCycle % 3 === 0) {
        renderSurface();
        renderScanner();
      }
    }

    function renderHeader() {
      document.getElementById('hdr-spot').textContent = spotPrice > 0 ? '$' + pFmt.format(spotPrice) : '--';
      renderSparkline(document.getElementById('spark-spot'), spotHistory, '#2fb2ff');
      renderSparkline(document.getElementById('spark-vol'), atmVolHistory, '#19d8a8');
    }

    // --- 3D Surface ---
    let surfaceInitialized = false;
    let surfaceInteracting = false;
    let surfaceDirty = false;

    // Smooth zoom state
    let zoomTarget = null;   // {x, y, z} target eye position
    let zoomCurrent = null;  // {x, y, z} current animated eye
    let zoomRafId = null;
    const ZOOM_LERP = 0.15;  // interpolation factor per frame (0-1, higher = snappier)
    const ZOOM_STEP = 0.08;  // distance factor per wheel tick

    function animateZoom(div) {
      if (!zoomTarget || !zoomCurrent) return;
      // Lerp toward target
      zoomCurrent.x += (zoomTarget.x - zoomCurrent.x) * ZOOM_LERP;
      zoomCurrent.y += (zoomTarget.y - zoomCurrent.y) * ZOOM_LERP;
      zoomCurrent.z += (zoomTarget.z - zoomCurrent.z) * ZOOM_LERP;

      Plotly.relayout(div, {
        'scene.camera.eye': { x: zoomCurrent.x, y: zoomCurrent.y, z: zoomCurrent.z }
      });

      // Keep animating until close enough
      const dx = zoomTarget.x - zoomCurrent.x;
      const dy = zoomTarget.y - zoomCurrent.y;
      const dz = zoomTarget.z - zoomCurrent.z;
      if (dx * dx + dy * dy + dz * dz > 1e-8) {
        zoomRafId = requestAnimationFrame(() => animateZoom(div));
      } else {
        zoomCurrent.x = zoomTarget.x;
        zoomCurrent.y = zoomTarget.y;
        zoomCurrent.z = zoomTarget.z;
        zoomRafId = null;
        // End interaction after animation settles
        surfaceInteracting = false;
        if (surfaceDirty) { surfaceDirty = false; renderSurface(); }
      }
    }

    function renderSurface() {
      const div = panels.surface ? panels.surface.chartDiv : null;
      if (!div) return;
      if (calibratedSlices.length === 0) return;

      // Defer updates while user is rotating/zooming
      if (surfaceInteracting && surfaceInitialized) {
        surfaceDirty = true;
        document.getElementById('calib-time').textContent = calibTimeUs > 0 ? calibTimeUs + ' us' : '';
        return;
      }

      // --- Compute data ---
      const marketX = [], marketY = [], marketZ = [], marketText = [];
      for (const sl of calibratedSlices) {
        for (const pt of sl.points) {
          if (pt.strike <= 0 || sl.forward <= 0) continue;
          marketX.push(Math.log(pt.strike / sl.forward));
          marketY.push(sl.T);
          marketZ.push(pt.market_iv);
          marketText.push(
            'Strike: $' + pt.strike.toLocaleString() +
            '<br>Maturity: ' + (sl.expiryCode || sl.T.toFixed(4) + 'y') +
            '<br>IV: ' + pt.market_iv.toFixed(2) + '%'
          );
        }
      }

      let kMin = -0.45, kMax = 0.45;
      if (marketX.length > 0) {
        kMin = Math.min(...marketX);
        kMax = Math.max(...marketX);
        if (kMax - kMin < 0.01) { kMin -= 0.25; kMax += 0.25; }
      }

      const gridN = 25;
      const kGrid = [];
      for (let i = 0; i < gridN; i++) kGrid.push(kMin + (kMax - kMin) * i / (gridN - 1));
      const tGrid = calibratedSlices.map(s => s.T);
      const kGridF64 = new Float64Array(kGrid);
      const { headers: slH, params: slP } = frameCache ? frameCache.packed : packSliceArrays(calibratedSlices);
      const flatZ = wasm.iv_grid(slH, slP, kGridF64);
      const zGrid = [];
      for (let i = 0; i < calibratedSlices.length; i++) {
        zGrid.push(Array.from(flatZ.subarray(i * gridN, (i + 1) * gridN)));
      }

      // Diff surface data (zeros if no baseline yet)
      let diffZ;
      if (baselineSurface && baselineSurface.length > 0) {
        const { headers: baseH, params: baseP } = packSliceArrays(baselineSurface);
        const baseFlatZ = wasm.iv_grid(baseH, baseP, kGridF64);
        diffZ = [];
        for (let i = 0; i < calibratedSlices.length; i++) {
          const base = baselineSurface.find(b => b.expiryCode === calibratedSlices[i].expiryCode);
          if (!base) { diffZ.push(kGrid.map(() => 0)); continue; }
          const baseIdx = baselineSurface.indexOf(base);
          const row = [];
          for (let j = 0; j < gridN; j++) {
            row.push(flatZ[i * gridN + j] - baseFlatZ[baseIdx * gridN + j]);
          }
          diffZ.push(row);
        }
      } else {
        diffZ = calibratedSlices.map(() => kGrid.map(() => 0));
      }

      // --- First render: create all 3 traces + layout ---
      if (!surfaceInitialized) {
        const traces = [
          {
            type: 'surface', name: 'Fitted', x: kGrid, y: tGrid, z: zGrid,
            opacity: 0.82, showscale: false,
            colorscale: [[0,'#144f83'],[0.5,'#1e8ac8'],[1,'#39dba7']],
          },
          {
            type: 'scatter3d', mode: 'markers', name: 'Market',
            x: marketX, y: marketY, z: marketZ,
            text: marketText,
            hovertemplate: '%{text}<extra></extra>',
            marker: { size: 2.2, color: '#d8e0ea', opacity: 0.85 },
          },
          {
            type: 'surface', name: 'Session diff', x: kGrid, y: tGrid, z: diffZ,
            opacity: 0.45, showscale: false,
            colorscale: [[0,'#ff4444'],[0.5,'#333333'],[1,'#44ff44']],
          },
        ];

        const layout = {
          ...darkLayout,
          uirevision: 'stable',
          margin: { l: 0, r: 0, b: 0, t: 0 },
          scene: {
            xaxis: { title: 'ln(K/F)', ...axisStyle },
            yaxis: { title: 'T (yr)', ...axisStyle },
            zaxis: { title: 'IV (%)', ...axisStyle },
            camera: { eye: { x: 1.65, y: 1.25, z: 0.8 } },
          },
          showlegend: false,
        };

        Plotly.newPlot(div, traces, layout, { responsive: true, displayModeBar: false, scrollZoom: false });
        surfaceInitialized = true;

        // Pause data updates during user drag (rotation/pan)
        div.addEventListener('mousedown', () => { surfaceInteracting = true; });
        window.addEventListener('mouseup', () => {
          if (surfaceInteracting && !zoomRafId) {
            surfaceInteracting = false;
            if (surfaceDirty) { surfaceDirty = false; renderSurface(); }
          }
        });

        // Smooth animated zoom — intercept wheel, animate camera with lerp
        div.addEventListener('wheel', (e) => {
          e.preventDefault();
          surfaceInteracting = true;

          // Read current camera eye
          const scene = div._fullLayout && div._fullLayout.scene;
          const cam = scene && scene._scene ? scene._scene.getCamera() : null;
          const eye = cam ? cam.eye : (zoomCurrent || { x: 1.65, y: 1.25, z: 0.8 });

          if (!zoomCurrent) zoomCurrent = { x: eye.x, y: eye.y, z: eye.z };
          // Use target if animation is in-flight, otherwise start from current eye
          const base = zoomTarget || { x: eye.x, y: eye.y, z: eye.z };

          const direction = e.deltaY > 0 ? 1 : -1; // positive = zoom out
          const scale = 1 + direction * ZOOM_STEP;
          zoomTarget = { x: base.x * scale, y: base.y * scale, z: base.z * scale };

          if (!zoomRafId) {
            zoomRafId = requestAnimationFrame(() => animateZoom(div));
          }
        }, { passive: false });
      } else {
        // --- Subsequent renders: restyle data only, never touch layout/camera ---
        Plotly.restyle(div, { x: [kGrid], y: [tGrid], z: [zGrid] }, [0]);
        Plotly.restyle(div, { x: [marketX], y: [marketY], z: [marketZ], text: [marketText] }, [1]);
        Plotly.restyle(div, { x: [kGrid], y: [tGrid], z: [diffZ] }, [2]);
      }

      surfaceDirty = false;
      document.getElementById('calib-time').textContent = calibTimeUs > 0 ? calibTimeUs + ' us' : '';
    }

    // --- Vol Change Heatmap ---
    function renderVolChange() {
      const div = panels.volchange ? panels.volchange.chartDiv : null;
      if (!div) return;
      if (calibratedSlices.length === 0) return;

      const expLabels = [];
      const strikeSet = new Set();
      for (const sl of calibratedSlices) {
        expLabels.push(sl.expiryLabel);
        for (const pt of sl.points) strikeSet.add(pt.strike);
      }
      const strikes = [...strikeSet].sort((a, b) => a - b);
      // Subsample if too many strikes
      const maxStrikes = 30;
      const step = strikes.length > maxStrikes ? Math.ceil(strikes.length / maxStrikes) : 1;
      const sampledStrikes = strikes.filter((_, i) => i % step === 0);

      const z = [];
      for (const sl of calibratedSlices) {
        const row = [];
        const ptMap = new Map();
        for (const pt of sl.points) ptMap.set(pt.strike, pt.market_iv);
        for (const strike of sampledStrikes) {
          const curIv = ptMap.get(strike);
          const prevIv = prevIvMap.get(sl.expiryCode + '|' + strike);
          if (curIv !== undefined && prevIv !== undefined) {
            row.push(curIv - prevIv);
          } else {
            row.push(0);
          }
        }
        z.push(row);
      }

      Plotly.react(div, [{
        type: 'heatmap', x: sampledStrikes.map(s => pFmt.format(s)),
        y: expLabels, z, colorscale: [[0,'#2255bb'],[0.5,'#1a1a2e'],[1,'#bb2222']],
        showscale: true, colorbar: { title: 'IV chg', titleside: 'right', thickness: 10, len: 0.6 },
        zmin: -2, zmax: 2,
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Smile Slice ---
    function renderSmile() {
      const div = panels.smile ? panels.smile.chartDiv : null;
      if (!div) return;
      ensureExpirySelection();
      if (!activeExpiry || calibratedSlices.length === 0) return;

      const slice = calibratedSlices.find(s => s.expiryCode === activeExpiry);
      if (!slice) return;

      const pts = slice.points;
      const x = pts.map(p => Math.log(p.strike / slice.forward));
      const marketIv = pts.map(p => p.market_iv);
      const fittedIv = pts.map(p => p.fitted_iv);
      const bidIv = pts.map(p => p.bid_iv);
      const askIv = pts.map(p => p.ask_iv);

      const traces = [];

      // Bid-ask ribbon (only if we have valid bid/ask)
      const hasBidAsk = bidIv.some(v => v > 0) && askIv.some(v => v > 0);
      if (hasBidAsk) {
        traces.push({
          type: 'scatter', mode: 'lines', name: 'bid IV', x, y: bidIv,
          line: { color: 'rgba(47,178,255,0.3)', width: 0 },
          showlegend: false,
        });
        traces.push({
          type: 'scatter', mode: 'lines', name: 'ask IV', x, y: askIv,
          line: { color: 'rgba(47,178,255,0.3)', width: 0 },
          fill: 'tonexty', fillcolor: 'rgba(47,178,255,0.12)',
          showlegend: false,
        });
      }

      traces.push({
        type: 'scatter', mode: 'markers', name: 'market', x, y: marketIv,
        marker: { color: '#d8e0ea', size: 4.5 },
      });
      traces.push({
        type: 'scatter', mode: 'lines', name: 'fitted', x, y: fittedIv,
        line: { color: '#19d8a8', width: 2 },
      });

      Plotly.react(div, traces, {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 40, r: 8, b: 30, t: 6 },
        xaxis: { title: 'ln(K/F)', ...axisStyle },
        yaxis: { title: 'IV (%)', ...axisStyle },
        legend: { orientation: 'h', y: 1.02, x: 0.01, font: { size: 9 } },
        transition: { duration: 120, easing: 'linear' },
      }, { responsive: true, displayModeBar: false });
    }

    function ensureExpirySelection() {
      const sel = panels.smile ? panels.smile.expirySelect : null;
      if (!sel) return;
      const expiries = calibratedSlices.map(s => s.expiryCode);
      const prev = activeExpiry;
      sel.innerHTML = '';
      for (const e of expiries) {
        const opt = document.createElement('option');
        opt.value = e; opt.textContent = e;
        sel.appendChild(opt);
      }
      if (expiries.length === 0) { activeExpiry = ''; return; }
      activeExpiry = (prev && expiries.includes(prev)) ? prev : expiries[0];
      sel.value = activeExpiry;
    }

    // --- Greeks Heatmap ---
    function renderGreeks() {
      const div = panels.greeks ? panels.greeks.chartDiv : null;
      if (!div || !wasmReady) return;
      if (calibratedSlices.length === 0 || spotPrice <= 0) return;

      // Pick a subset of strikes and expiries
      const expLabels = calibratedSlices.map(s => s.expiryLabel);
      const allStrikes = new Set();
      for (const sl of calibratedSlices) {
        for (const pt of sl.points) allStrikes.add(pt.strike);
      }
      const strikes = [...allStrikes].sort((a, b) => a - b);
      const maxS = 20;
      const step = strikes.length > maxS ? Math.ceil(strikes.length / maxS) : 1;
      const sampledStrikes = strikes.filter((_, i) => i % step === 0);

      const greekIdx = { delta: 0, gamma: 1, vega: 2, theta: 3 }[activeGreek] ?? 0;

      // Batch IV lookup for all (slice, strike) pairs
      const { headers: gH, params: gP } = frameCache ? frameCache.packed : packSliceArrays(calibratedSlices);
      const gKVals = [], gSliceIdx = [];
      for (let si = 0; si < calibratedSlices.length; si++) {
        const sl = calibratedSlices[si];
        for (const strike of sampledStrikes) {
          gKVals.push(Math.log(strike / sl.forward));
          gSliceIdx.push(si);
        }
      }
      const gIvs = wasm.batch_slice_iv(gH, gP, new Float64Array(gKVals), new Uint32Array(gSliceIdx));

      const z = [];
      let gIdx = 0;
      for (const sl of calibratedSlices) {
        const row = [];
        for (const strike of sampledStrikes) {
          const iv = gIvs[gIdx++];
          if (!isFinite(iv) || iv <= 0 || sl.T <= 0) { row.push(0); continue; }
          const greeks = wasm.bsm_greeks_wasm(spotPrice, strike, 0.05, 0.0, iv / 100, sl.T, true);
          row.push(greeks[greekIdx]);
        }
        z.push(row);
      }

      const colorscales = {
        delta: [[0,'#0d2847'],[0.5,'#1a3a5c'],[1,'#2fb2ff']],
        gamma: [[0,'#0d2820'],[0.5,'#1a5c3a'],[1,'#19d8a8']],
        vega:  [[0,'#28200d'],[0.5,'#5c4a1a'],[1,'#ffb347']],
        theta: [[0,'#280d0d'],[0.5,'#5c1a1a'],[1,'#ff7a7a']],
      };

      Plotly.react(div, [{
        type: 'heatmap',
        x: sampledStrikes.map(s => pFmt.format(s)),
        y: expLabels, z,
        colorscale: colorscales[activeGreek] || colorscales.delta,
        showscale: true,
        colorbar: { title: activeGreek, titleside: 'right', thickness: 10, len: 0.6 },
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Term Structure ---
    function renderTerm() {
      const div = panels.term ? panels.term.chartDiv : null;
      if (!div) return;
      if (calibratedSlices.length === 0) return;

      const expLabels = calibratedSlices.map(s => s.expiryLabel);
      const atmVols = calibratedSlices.map(s => s.atmVol);

      const traces = [{
        type: 'scatter', mode: 'lines+markers', name: 'ATM IV',
        x: expLabels, y: atmVols,
        line: { color: '#2fb2ff', width: 2 },
        marker: { color: '#2fb2ff', size: 5 },
      }];

      // 25-delta RR and BF (from per-frame cache)
      const d25 = frameCache ? frameCache.d25 : wasm.find_25d_strikes_batch(
        ...Object.values(packSliceArrays(calibratedSlices)));
      const atmIvFlat = frameCache ? frameCache.atmIv : wasm.iv_grid(
        ...Object.values(packSliceArrays(calibratedSlices)), new Float64Array([0]));
      const rr25 = [], bf25 = [];
      for (let i = 0; i < calibratedSlices.length; i++) {
        const ivCall = d25[i * 4 + 2];
        const ivPut = d25[i * 4 + 3];
        const atmIv = atmIvFlat[i];
        if (isFinite(ivCall) && isFinite(ivPut)) {
          rr25.push(ivCall - ivPut);
          bf25.push(0.5 * (ivCall + ivPut) - atmIv);
        } else {
          rr25.push(NaN);
          bf25.push(NaN);
        }
      }

      traces.push({
        type: 'scatter', mode: 'lines+markers', name: 'RR25',
        x: expLabels, y: rr25, yaxis: 'y2',
        line: { color: '#ff7a7a', width: 1.5, dash: 'dot' },
        marker: { size: 4 },
      });
      traces.push({
        type: 'scatter', mode: 'lines+markers', name: 'BF25',
        x: expLabels, y: bf25, yaxis: 'y2',
        line: { color: '#ffb347', width: 1.5, dash: 'dot' },
        marker: { size: 4 },
      });

      // Realized vol horizontal line
      const rvol = computeRealizedVol();
      if (isFinite(rvol) && rvol > 0) {
        traces.push({
          type: 'scatter', mode: 'lines', name: 'Realized',
          x: [expLabels[0], expLabels[expLabels.length - 1]], y: [rvol, rvol],
          line: { color: '#888', width: 1, dash: 'dash' },
        });
      }

      Plotly.react(div, traces, {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 40, r: 50, b: 30, t: 6 },
        xaxis: { title: '', ...axisStyle },
        yaxis: { title: 'ATM IV (%)', ...axisStyle },
        yaxis2: { title: 'RR/BF', ...axisStyle, overlaying: 'y', side: 'right' },
        legend: { orientation: 'h', y: 1.05, x: 0.01, font: { size: 9 } },
        showlegend: true,
        transition: { duration: 120, easing: 'linear' },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Metrics & Skew Table ---
    function renderMetrics() {
      const p = panels.metrics;
      if (!p) return;

      if (p.mSpot) p.mSpot.textContent = spotPrice > 0 ? pFmt.format(spotPrice) : '--';
      if (p.mOptions) p.mOptions.textContent = chain.size || '--';
      if (p.mExpiries) p.mExpiries.textContent = calibratedSlices.length || '--';
      if (p.mTps) p.mTps.textContent = ticksPerSec > 0 ? pFmt1.format(ticksPerSec) : '--';
      if (p.mCalib) p.mCalib.textContent = calibTimeUs > 0 ? calibTimeUs.toString() : '--';

      const rvol = computeRealizedVol();
      if (p.mRvol) p.mRvol.textContent = isFinite(rvol) ? pFmt1.format(rvol) + '%' : '--';

      const tbody = p.skewTbody;
      if (!tbody) return;
      tbody.innerHTML = '';

      // Batch 25-delta (from per-frame cache)
      const mD25 = frameCache ? frameCache.d25 : wasm.find_25d_strikes_batch(
        ...Object.values(packSliceArrays(calibratedSlices)));
      const mAtmIv = frameCache ? frameCache.atmIv : wasm.iv_grid(
        ...Object.values(packSliceArrays(calibratedSlices)), new Float64Array([0]));

      for (let i = 0; i < calibratedSlices.length; i++) {
        const sl = calibratedSlices[i];
        const ivCall = mD25[i * 4 + 2];
        const ivPut = mD25[i * 4 + 3];
        const atmIv = mAtmIv[i];
        const rr25 = isFinite(ivCall) && isFinite(ivPut) ? (ivCall - ivPut) : NaN;
        const bf25 = isFinite(ivCall) && isFinite(ivPut) ? (0.5*(ivCall+ivPut) - atmIv) : NaN;

        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${sl.expiryLabel}</td>`
          + `<td>${pFmt1.format(sl.atmVol)}</td>`
          + `<td>${pFmt.format(sl.rmse)}</td>`
          + `<td>${sl.skew.toFixed(4)}</td>`
          + `<td>${sl.kurtProxy.toFixed(4)}</td>`
          + `<td>${isFinite(rr25) ? pFmt1.format(rr25) : '-'}</td>`
          + `<td>${isFinite(bf25) ? pFmt1.format(bf25) : '-'}</td>`
          + `<td>${sl.n}</td>`;
        tbody.appendChild(tr);
      }
    }

    // =====================================================================
    //  Mispricing Scanner
    // =====================================================================
    let edgeThreshold = 1.0;
    let edgeSideFilter = 'all';

    function renderScanner() {
      if (!wasmReady || calibratedSlices.length === 0 || spotPrice <= 0) return;

      const heatDiv = panels.scanner ? panels.scanner.heatmapDiv : null;
      const edgeTbody = panels.scanner ? panels.scanner.edgeTbody : null;
      if (!heatDiv || !edgeTbody) return;

      // --- Phase 0: batch model-IV lookup via WASM ---
      const { headers: scH, params: scP } = frameCache ? frameCache.packed : packSliceArrays(calibratedSlices);
      // Build slice index map for fast lookup
      const sliceIdxMap = new Map();
      calibratedSlices.forEach((sl, i) => sliceIdxMap.set(sl.expiryCode, i));

      // Collect k-values and slice indices for all options
      const preKVals = [], preSliceIdx = [], preItems = [];
      for (const sl of calibratedSlices) {
        for (const [name, q] of chain) {
          if (q.expiryCode !== sl.expiryCode) continue;
          if (!q.mark_iv || q.mark_iv <= 0 || q.strike <= 0) continue;
          const k = Math.log(q.strike / sl.forward);
          preKVals.push(k);
          preSliceIdx.push(sliceIdxMap.get(sl.expiryCode));
          preItems.push({ name, q, sl, k });
        }
      }

      const scIvs = preKVals.length > 0
        ? wasm.batch_slice_iv(scH, scP, new Float64Array(preKVals), new Uint32Array(preSliceIdx))
        : [];

      // --- Phase 1: collect all pricing requests into flat arrays ---
      const pricingRequests = [];
      const bSpots = [], bStrikes = [], bRates = [], bDivs = [], bVols = [], bMats = [], bCalls = [];

      for (let pi = 0; pi < preItems.length; pi++) {
        const { name, q, sl } = preItems[pi];
        const modelIvPct = scIvs[pi];
        if (!isFinite(modelIvPct) || modelIvPct <= 0) continue;

        const marketIvPct = q.mark_iv * 100;
        const ivEdge = modelIvPct - marketIvPct;
        const modelSigma = modelIvPct / 100;
        const marketMid = q.mark_price * spotPrice;
        const callFlag = q.isCall ? 1 : 0;

        // Theo price (always needed)
        const theoIdx = bSpots.length;
        bSpots.push(spotPrice); bStrikes.push(q.strike); bRates.push(0.05);
        bDivs.push(0.0); bVols.push(modelSigma); bMats.push(sl.T); bCalls.push(callFlag);

        // Bid price (conditional)
        const bidIdx = q.bid_iv > 0 ? bSpots.length : -1;
        if (bidIdx >= 0) {
          bSpots.push(spotPrice); bStrikes.push(q.strike); bRates.push(0.05);
          bDivs.push(0.0); bVols.push(q.bid_iv); bMats.push(sl.T); bCalls.push(callFlag);
        }

        // Ask price (conditional)
        const askIdx = q.ask_iv > 0 ? bSpots.length : -1;
        if (askIdx >= 0) {
          bSpots.push(spotPrice); bStrikes.push(q.strike); bRates.push(0.05);
          bDivs.push(0.0); bVols.push(q.ask_iv); bMats.push(sl.T); bCalls.push(callFlag);
        }

        pricingRequests.push({ name, expiryCode: sl.expiryCode, T: sl.T,
          strike: q.strike, isCall: q.isCall, marketIvPct, modelIvPct, ivEdge,
          marketMid, theoIdx, bidIdx, askIdx });
      }

      // --- Phase 2: single WASM batch call for all BS prices ---
      const prices = bSpots.length > 0
        ? wasm.bs_price_batch_wasm(
            new Float64Array(bSpots), new Float64Array(bStrikes),
            new Float64Array(bRates), new Float64Array(bDivs),
            new Float64Array(bVols), new Float64Array(bMats),
            new Uint8Array(bCalls))
        : [];

      // --- Phase 3: unpack into edge objects ---
      const edges = [];
      for (const req of pricingRequests) {
        const theoPrice = prices[req.theoIdx];
        const bidPrice = req.bidIdx >= 0 ? prices[req.bidIdx] : NaN;
        const askPrice = req.askIdx >= 0 ? prices[req.askIdx] : NaN;
        const dollarEdge = theoPrice - req.marketMid;

        edges.push({
          name: req.name,
          expiryCode: req.expiryCode,
          T: req.T,
          strike: req.strike,
          isCall: req.isCall,
          marketIvPct: req.marketIvPct,
          modelIvPct: req.modelIvPct,
          ivEdge: req.ivEdge,
          bidPrice,
          askPrice,
          marketMid: req.marketMid,
          theoPrice,
          dollarEdge,
          absIvEdge: Math.abs(req.ivEdge),
          buySignal: isFinite(askPrice) && theoPrice > askPrice,
          sellSignal: isFinite(bidPrice) && theoPrice < bidPrice,
        });
      }

      // --- Heatmap: IV edge by strike x expiry ---
      const expLabels = calibratedSlices.map(s => s.expiryLabel);
      const strikeSet = new Set();
      for (const e of edges) strikeSet.add(e.strike);
      const strikes = [...strikeSet].sort((a, b) => a - b);
      const maxStrikes = 35;
      const step = strikes.length > maxStrikes ? Math.ceil(strikes.length / maxStrikes) : 1;
      const sampledStrikes = strikes.filter((_, i) => i % step === 0);

      // Build lookup: "expiryCode|strike" -> best ivEdge (prefer call for dedup)
      const edgeLookup = new Map();
      for (const e of edges) {
        const key = e.expiryCode + '|' + e.strike;
        const existing = edgeLookup.get(key);
        if (!existing || e.absIvEdge > Math.abs(existing.ivEdge)) {
          edgeLookup.set(key, e);
        }
      }

      const heatZ = [];
      const heatText = [];
      for (const sl of calibratedSlices) {
        const row = [];
        const textRow = [];
        for (const strike of sampledStrikes) {
          const e = edgeLookup.get(sl.expiryCode + '|' + strike);
          if (e) {
            row.push(e.ivEdge);
            textRow.push(
              `${e.isCall ? 'C' : 'P'} ${sl.expiryCode} $${pFmt.format(strike)}`
              + `<br>Mkt IV: ${e.marketIvPct.toFixed(1)}%`
              + `<br>Mdl IV: ${e.modelIvPct.toFixed(1)}%`
              + `<br>Edge: ${e.ivEdge > 0 ? '+' : ''}${e.ivEdge.toFixed(2)} vol`
              + `<br>Theo: $${pFmt.format(e.theoPrice)}`
              + `<br>Mid: $${pFmt.format(e.marketMid)}`
              + (e.buySignal ? '<br><b>BUY (theo > ask)</b>' : '')
              + (e.sellSignal ? '<br><b>SELL (theo < bid)</b>' : '')
            );
          } else {
            row.push(0);
            textRow.push('');
          }
        }
        heatZ.push(row);
        heatText.push(textRow);
      }

      const maxEdge = Math.max(3, ...edges.map(e => e.absIvEdge));
      Plotly.react(heatDiv, [{
        type: 'heatmap',
        x: sampledStrikes.map(s => pFmt.format(s)),
        y: expLabels,
        z: heatZ,
        text: heatText,
        hovertemplate: '%{text}<extra></extra>',
        colorscale: [
          [0, '#ff4444'],
          [0.35, '#cc2222'],
          [0.5, '#1a1a2e'],
          [0.65, '#118855'],
          [1, '#19d8a8'],
        ],
        zmin: -maxEdge, zmax: maxEdge,
        showscale: true,
        colorbar: {
          title: 'IV edge (vol pts)',
          titleside: 'right',
          thickness: 10,
          len: 0.8,
        },
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });

      // --- Table: top opportunities sorted by |edge| ---
      const filtered = edges
        .filter(e => e.absIvEdge >= edgeThreshold)
        .filter(e => {
          if (edgeSideFilter === 'buy') return e.ivEdge > 0;
          if (edgeSideFilter === 'sell') return e.ivEdge < 0;
          return true;
        })
        .sort((a, b) => b.absIvEdge - a.absIvEdge)
        .slice(0, 40);

      edgeTbody.innerHTML = '';
      for (const e of filtered) {
        const isBuy = e.ivEdge > 0;
        const edgeCls = isBuy ? 'edge-buy' : 'edge-sell';
        const strongCls = e.absIvEdge >= edgeThreshold * 2 ? ' edge-strong' : '';
        const actionable = (isBuy && e.buySignal) || (!isBuy && e.sellSignal);
        const rowCls = actionable ? (isBuy ? 'edge-actionable' : 'edge-actionable sell') : '';
        const signal = e.buySignal ? 'BUY' : (e.sellSignal ? 'SELL' : '-');
        const signalCls = e.buySignal ? 'edge-buy edge-strong' : (e.sellSignal ? 'edge-sell edge-strong' : '');

        const tr = document.createElement('tr');
        if (rowCls) tr.className = rowCls;
        tr.innerHTML =
          `<td>${e.expiryCode}</td>`
          + `<td style="text-align:right">${pFmt.format(e.strike)}</td>`
          + `<td>${e.isCall ? 'C' : 'P'}</td>`
          + `<td style="text-align:right">${e.marketIvPct.toFixed(1)}</td>`
          + `<td style="text-align:right">${e.modelIvPct.toFixed(1)}</td>`
          + `<td style="text-align:right" class="${edgeCls}${strongCls}">${e.ivEdge > 0 ? '+' : ''}${e.ivEdge.toFixed(2)}</td>`
          + `<td style="text-align:right">${isFinite(e.bidPrice) ? pFmt.format(e.bidPrice) : '-'}</td>`
          + `<td style="text-align:right">${isFinite(e.askPrice) ? pFmt.format(e.askPrice) : '-'}</td>`
          + `<td style="text-align:right">${pFmt.format(e.marketMid)}</td>`
          + `<td style="text-align:right">${pFmt.format(e.theoPrice)}</td>`
          + `<td style="text-align:right" class="${edgeCls}">${e.dollarEdge > 0 ? '+' : ''}${pFmt.format(e.dollarEdge)}</td>`
          + `<td class="${signalCls}">${signal}</td>`;
        edgeTbody.appendChild(tr);
      }
    }

    // =====================================================================
    //  Deribit Connection (REST seed + WebSocket stream)
    // =====================================================================
    const DERIBIT_REST = 'https://www.deribit.com/api/v2/public';
    const DERIBIT_WS = 'wss://www.deribit.com/ws/api/v2';

    const statusPill = document.getElementById('status-pill');
    function setStatus(state, text) {
      statusPill.className = 'status-pill ' + state;
      statusPill.textContent = text;
    }

    async function seedFromRest() {
      try {
        setStatus('connecting', 'seeding...');

        const [bookResp, indexResp] = await Promise.all([
          fetch(`${DERIBIT_REST}/get_book_summary_by_currency?currency=BTC&kind=option`),
          fetch(`${DERIBIT_REST}/get_index_price?index_name=btc_usd`),
        ]);

        const bookData = await bookResp.json();
        const indexData = await indexResp.json();

        if (indexData.result && indexData.result.index_price) {
          spotPrice = indexData.result.index_price;
        }

        const entries = bookData.result || [];
        let count = 0;
        for (const entry of entries) {
          const name = entry.instrument_name;
          if (!name) continue;
          const parsed = parseInstrumentName(name);
          if (!parsed) continue;

          const markIv = normalizeIv(entry.mark_iv || entry.iv || 0);
          if (isNaN(markIv) || markIv <= 0) continue;

          const underlying = (entry.underlying_price || entry.index_price || spotPrice);
          noteQuote(name, {
            strike: parsed.strike,
            expiryCode: parsed.expiry,
            expiryDate: parsed.expiryDate,
            isCall: parsed.isCall,
            mark_price: Math.max(entry.mark_price || 0, 0),
            mark_iv: markIv,
            underlying_price: underlying > 0 ? underlying : spotPrice,
            bid_iv: normalizeIv(entry.bid_iv || 0) || 0,
            ask_iv: normalizeIv(entry.ask_iv || 0) || 0,
            open_interest: Math.max(entry.open_interest || 0, 0),
          });
          count++;
        }
        console.log(`[rest] seeded ${count} options, spot=${spotPrice}`);
        scheduleCalibration();
      } catch (e) {
        console.error('[rest] seed failed:', e);
      }
    }

    function connectWs() {
      setStatus('connecting', 'connecting...');
      const ws = new WebSocket(DERIBIT_WS);

      ws.onopen = () => {
        setStatus('connected', 'live');
        ws.send(JSON.stringify({
          jsonrpc: '2.0', id: 1,
          method: 'public/subscribe',
          params: { channels: ['markprice.options.btc_usd'] },
        }));
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          if (!msg.params || !msg.params.data) return;
          const channel = msg.params.channel;
          if (channel !== 'markprice.options.btc_usd') return;

          const data = msg.params.data;
          const nodes = Array.isArray(data) ? data : [data];

          // Collect nested quote nodes
          const quoteNodes = [];
          function collect(val) {
            if (Array.isArray(val)) { val.forEach(collect); return; }
            if (val && typeof val === 'object') {
              if (val.instrument_name) { quoteNodes.push(val); return; }
              for (const v of Object.values(val)) {
                if (typeof v === 'object') collect(v);
              }
            }
          }
          collect(nodes);

          let anyUpdate = false;
          for (const node of quoteNodes) {
            const name = node.instrument_name || node.instrument;
            if (!name) continue;
            const parsed = parseInstrumentName(name);
            if (!parsed) continue;

            const markIv = normalizeIv(node.mark_iv || node.iv || 0);
            const underlying = node.underlying_price || node.index_price;
            if (underlying && underlying > 0) spotPrice = underlying;

            const existing = chain.get(name);
            if (markIv > 0 || existing) {
              const q = existing || {
                strike: parsed.strike,
                expiryCode: parsed.expiry,
                expiryDate: parsed.expiryDate,
                isCall: parsed.isCall,
                mark_price: 0,
                mark_iv: 0,
                underlying_price: spotPrice,
                bid_iv: 0,
                ask_iv: 0,
                open_interest: 0,
              };
              if (markIv > 0) q.mark_iv = markIv;
              if (node.mark_price !== undefined) q.mark_price = Math.max(node.mark_price, 0);
              if (underlying > 0) q.underlying_price = underlying;
              const bidIv = normalizeIv(node.bid_iv || 0);
              if (bidIv > 0) q.bid_iv = bidIv;
              const askIv = normalizeIv(node.ask_iv || 0);
              if (askIv > 0) q.ask_iv = askIv;
              if (node.open_interest !== undefined) q.open_interest = Math.max(node.open_interest, 0);

              chain.set(name, q);
              dirty = true;
              tickCount++;
              anyUpdate = true;
            }
          }

          if (anyUpdate) scheduleCalibration();
        } catch (e) {
          // ignore parse errors
        }
      };

      ws.onerror = () => {
        setStatus('disconnected', 'ws error');
      };

      ws.onclose = () => {
        setStatus('disconnected', 'reconnecting...');
        setTimeout(connectWs, 2000);
      };
    }

    // =====================================================================
    //  Dockview Initialization
    // =====================================================================
    const LAYOUT_KEY = 'vol-terminal-layout';

    function createDefaultLayout(dv) {
      const surface = dv.addPanel({ id: 'surface', component: 'surface', title: '3D Vol Surface' });
      dv.addPanel({ id: 'volchange', component: 'volchange', title: 'IV Change Heatmap',
        position: { referencePanel: 'surface', direction: 'right' } });
      dv.addPanel({ id: 'smile', component: 'smile', title: 'Smile Slice',
        position: { referencePanel: 'surface', direction: 'below' } });
      dv.addPanel({ id: 'greeks', component: 'greeks', title: 'Greeks Heatmap',
        position: { referencePanel: 'volchange', direction: 'below' } });
      dv.addPanel({ id: 'term', component: 'term', title: 'Term Structure',
        position: { referencePanel: 'smile', direction: 'below' } });
      dv.addPanel({ id: 'metrics', component: 'metrics', title: 'Metrics & Skew',
        position: { referencePanel: 'greeks', direction: 'below' } });
      dv.addPanel({ id: 'scanner', component: 'scanner', title: 'Mispricing Scanner',
        position: { referencePanel: 'term', direction: 'below' } });
    }

    const dockviewContainer = document.getElementById('dockview');
    const dockview = new DockviewComponent(dockviewContainer, {
      createComponent(options) {
        switch (options.name) {
          case 'surface': return new SurfacePanel();
          case 'volchange': return new VolChangePanel();
          case 'smile': return new SmilePanel();
          case 'greeks': return new GreeksPanel();
          case 'term': return new TermPanel();
          case 'metrics': return new MetricsPanel();
          case 'scanner': return new ScannerPanel();
          default: {
            const el = document.createElement('div');
            el.className = 'dock-content';
            el.textContent = 'Unknown panel: ' + options.name;
            return { element: el, init() {}, dispose() {} };
          }
        }
      }
    });

    // Try to restore saved layout, fall back to default
    const savedLayout = localStorage.getItem(LAYOUT_KEY);
    if (savedLayout) {
      try {
        dockview.fromJSON(JSON.parse(savedLayout));
        console.log('[dockview] restored layout from localStorage');
      } catch (e) {
        console.warn('[dockview] failed to restore layout, using default:', e);
        createDefaultLayout(dockview);
      }
    } else {
      createDefaultLayout(dockview);
    }

    // Persist layout changes (debounced)
    let layoutSaveTimer = null;
    dockview.onDidLayoutChange(() => {
      clearTimeout(layoutSaveTimer);
      layoutSaveTimer = setTimeout(() => {
        try {
          localStorage.setItem(LAYOUT_KEY, JSON.stringify(dockview.toJSON()));
        } catch (e) {
          // localStorage might be full or unavailable
        }
      }, 500);
    });

    // Reset Layout button
    document.getElementById('reset-layout').addEventListener('click', () => {
      localStorage.removeItem(LAYOUT_KEY);
      window.location.reload();
    });

    // =====================================================================
    //  Bootstrap
    // =====================================================================
    (async () => {
      await wasmPromise;
      if (!wasmReady) return; // fatal: WASM failed to load
      await seedFromRest();
      connectWs();

      // Deferred GPU MC test — runs after page is live and data is flowing.
      setTimeout(async () => {
        if (!wasmReady || !navigator.gpu || typeof wasm.gpu_mc_price_european !== 'function') {
          if (!navigator.gpu) console.log('[gpu-mc] WebGPU not available in this browser');
          return;
        }
        try {
          const mc = await wasm.gpu_mc_price_european(
            100, 100, 0.05, 0.2, 1.0, 65536, 252, 42, true
          );
          console.log('[gpu-mc] price:', mc.price, 'stderr:', mc.stderr);
        } catch (gpuErr) {
          console.warn('[gpu-mc] WebGPU MC failed:', gpuErr.message || gpuErr);
        }
      }, 2000);
    })();
  </script>
</body>
</html>
