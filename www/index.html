<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTC Options Vol Terminal</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dockview-core@4.3.1/dist/styles/dockview.css">
  <style>
    :root {
      --bg: #070a0f;
      --panel: #11161f;
      --border: #263241;
      --fg: #d8e0ea;
      --muted: #8ea1b8;
      --accent: #2fb2ff;
      --accent2: #19d8a8;
      --danger: #ff7a7a;
      --warn: #ffb347;
      --mono: "JetBrains Mono", "SFMono-Regular", Menlo, Monaco, Consolas, monospace;
      --sans: "IBM Plex Sans", "Segoe UI", Helvetica, Arial, sans-serif;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      color: var(--fg);
      font-family: var(--sans);
      background:
        radial-gradient(1000px 700px at 12% -20%, #15314f 0%, rgba(21,49,79,0) 60%),
        radial-gradient(900px 650px at 100% 0%, #0f2d25 0%, rgba(15,45,37,0) 58%),
        linear-gradient(180deg, #06080c 0%, #070a0f 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ---- Header ---- */
    .header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 8px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(17,22,31,0.85);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      white-space: nowrap;
    }
    .header-spot {
      font-family: var(--mono);
      font-size: 16px;
      color: var(--accent2);
      min-width: 110px;
    }
    .sparkline-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }
    .sparkline-wrap svg { display: block; }
    .status-pill {
      font-size: 11px;
      font-family: var(--mono);
      padding: 3px 10px;
      border-radius: 20px;
      border: 1px solid var(--border);
      white-space: nowrap;
    }
    .status-pill.connected { color: var(--accent2); border-color: var(--accent2); }
    .status-pill.connecting { color: var(--warn); border-color: var(--warn); }
    .status-pill.disconnected { color: var(--danger); border-color: var(--danger); }

    /* ---- Dockview panel content ---- */
    .dock-content {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      padding: 6px 8px;
      background: color-mix(in srgb, var(--panel) 92%, black);
    }
    .panel-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      flex-shrink: 0;
    }
    .panel-title {
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .chart-area {
      flex: 1;
      min-height: 0;
    }

    /* ---- Toolbar ---- */
    .toolbar {
      display: flex;
      gap: 4px;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
    }
    select, .tab-btn {
      background: #0d141d;
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: var(--mono);
      font-size: 11px;
      cursor: pointer;
    }
    .tab-btn.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    /* ---- Metrics table ---- */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 3px 8px;
      font-size: 11px;
      margin-bottom: 6px;
    }
    .metrics-grid .k { color: var(--muted); }
    .metrics-grid .v { text-align: right; font-family: var(--mono); }
    .tbl-wrap {
      flex: 1;
      overflow: auto;
      min-height: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    th, td {
      padding: 2px 0;
      border-bottom: 1px solid rgba(142,161,184,0.12);
      text-align: right;
      font-family: var(--mono);
    }
    th:first-child, td:first-child {
      text-align: left;
      font-family: var(--sans);
      color: var(--muted);
    }
    th { color: var(--muted); font-weight: 500; }

    /* ---- Mispricing Scanner ---- */
    .scanner-wrap {
      display: flex;
      gap: 6px;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    .scanner-heatmap {
      flex: 1.2;
      min-height: 0;
    }
    .scanner-table-wrap {
      flex: 1;
      overflow: auto;
      min-height: 0;
    }
    .scanner-table-wrap table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    .scanner-table-wrap th {
      position: sticky;
      top: 0;
      background: var(--panel);
      z-index: 1;
    }
    .scanner-table-wrap td { white-space: nowrap; }
    .edge-buy { color: var(--accent2); }
    .edge-sell { color: var(--danger); }
    .edge-strong { font-weight: 700; }
    .edge-actionable { background: rgba(25,216,168,0.08); }
    .edge-actionable.sell { background: rgba(255,122,122,0.08); }

    /* ---- Trade Flow Tape ---- */
    .tape-wrap { flex: 1; overflow: auto; min-height: 0; }
    .tape-wrap table { width: 100%; border-collapse: collapse; font-size: 10px; }
    .tape-wrap th { position: sticky; top: 0; background: var(--panel); z-index: 1; }
    .tape-wrap td { white-space: nowrap; }
    .trade-buy { color: var(--accent2); }
    .trade-sell { color: var(--danger); }
    .trade-large { font-weight: 700; }
    .flow-metrics {
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 2px 6px; font-size: 10px; margin-bottom: 4px; flex-shrink: 0;
    }
    .flow-metrics .k { color: var(--muted); }
    .flow-metrics .v { font-family: var(--mono); text-align: right; }

    /* ---- Strategy Builder ---- */
    .strategy-split { display: flex; gap: 6px; flex: 1; min-height: 0; overflow: hidden; }
    .strategy-legs { flex: 0 0 40%; overflow: auto; min-height: 0; display: flex; flex-direction: column; }
    .strategy-legs table { width: 100%; border-collapse: collapse; font-size: 10px; }
    .strategy-legs th { position: sticky; top: 0; background: var(--panel); z-index: 1; }
    .strategy-chart { flex: 1; min-height: 0; display: flex; flex-direction: column; }
    .strategy-chart .chart-area { flex: 1; min-height: 0; }
    .slider-row { display: flex; gap: 8px; align-items: center; font-size: 10px; color: var(--muted); padding: 2px 0; flex-shrink: 0; }
    .slider-row input[type="range"] { flex: 1; accent-color: var(--accent); height: 14px; }
    .slider-row .slider-val { font-family: var(--mono); min-width: 50px; text-align: right; }
    .net-greeks {
      display: grid; grid-template-columns: repeat(4, 1fr);
      gap: 2px 6px; font-size: 10px; margin: 4px 0; padding: 3px 4px;
      background: rgba(47,178,255,0.05); border-radius: 4px;
    }
    .net-greeks .k { color: var(--muted); }
    .net-greeks .v { font-family: var(--mono); text-align: right; }
    .template-btns { display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 4px; }
    .template-btns .tab-btn { font-size: 9px; padding: 1px 5px; }

    /* ---- Vol Cone ---- */
    .volcone-metrics {
      display: grid; grid-template-columns: repeat(2, 1fr);
      gap: 2px 8px; font-size: 10px; margin-bottom: 4px; flex-shrink: 0;
    }
    .volcone-metrics .k { color: var(--muted); }
    .volcone-metrics .v { font-family: var(--mono); text-align: right; }

    /* ---- Funding ---- */
    .funding-metrics {
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 2px 6px; font-size: 10px; margin-bottom: 4px; flex-shrink: 0;
    }
    .funding-metrics .k { color: var(--muted); }
    .funding-metrics .v { font-family: var(--mono); text-align: right; }

    /* ---- Dockview theme overrides ---- */
    .dockview-theme-abyss {
      --dv-group-view-background-color: var(--panel);
      --dv-tabs-and-actions-container-background-color: color-mix(in srgb, var(--panel) 70%, black);
      --dv-separator-border: var(--border);
      --dv-activegroup-visiblepanel-tab-background-color: var(--panel);
      --dv-activegroup-hiddenpanel-tab-background-color: transparent;
      --dv-inactivegroup-visiblepanel-tab-background-color: color-mix(in srgb, var(--panel) 50%, black);
      --dv-inactivegroup-hiddenpanel-tab-background-color: transparent;
      --dv-activegroup-visiblepanel-tab-color: var(--fg);
      --dv-activegroup-hiddenpanel-tab-color: var(--muted);
      --dv-inactivegroup-visiblepanel-tab-color: var(--muted);
      --dv-inactivegroup-hiddenpanel-tab-color: var(--muted);
      --dv-tab-divider-color: var(--border);
      --dv-drag-over-background-color: rgba(47,178,255,0.1);
      --dv-drag-over-border-color: var(--accent);
    }

    /* ---- View Switcher ---- */
    .view-switcher {
      display: flex;
      gap: 2px;
      padding: 2px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    .view-switcher .tab-btn {
      font-size: 10px;
      padding: 3px 10px;
      border-radius: 4px;
      border: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "dockview-core": "https://esm.sh/dockview-core@4.3.1"
    }
  }
  </script>
</head>
<body>
  <!-- ===== Header ===== -->
  <div class="header">
    <div class="header-title">BTC Options Vol Terminal</div>
    <div class="header-spot" id="hdr-spot">--</div>
    <div class="sparkline-wrap">
      spot
      <svg id="spark-spot" width="80" height="22" viewBox="0 0 80 22"></svg>
    </div>
    <div class="sparkline-wrap">
      ATM vol
      <svg id="spark-vol" width="80" height="22" viewBox="0 0 80 22"></svg>
    </div>
    <div class="toolbar" style="margin-left: auto;">
      <label for="currency-select">currency</label>
      <select id="currency-select">
        <optgroup label="Inverse">
          <option value="BTC" selected>BTC</option>
          <option value="ETH">ETH</option>
        </optgroup>
        <optgroup label="Linear (USDC)">
          <option value="BTC_USDC">BTC-USDC</option>
          <option value="ETH_USDC">ETH-USDC</option>
          <option value="SOL_USDC">SOL-USDC</option>
          <option value="AVAX_USDC">AVAX-USDC</option>
        </optgroup>
      </select>
      <label for="model-select">model</label>
      <select id="model-select">
        <option value="svi" selected>SVI</option>
        <option value="sabr">SABR</option>
        <option value="vv">Vanna-Volga</option>
      </select>
      <span id="calib-time" style="font-family:var(--mono);font-size:10px;color:var(--muted)"></span>
    </div>
    <div class="view-switcher">
      <button class="tab-btn active" data-view="overview">Overview</button>
      <button class="tab-btn" data-view="analysis">Analysis</button>
      <button class="tab-btn" data-view="scanner">Scanner</button>
      <button class="tab-btn" data-view="trading">Trading</button>
      <button class="tab-btn" data-view="all">All</button>
    </div>
    <button id="reset-layout" class="tab-btn" title="Reset panel layout to default">Reset Layout</button>
    <div class="status-pill connecting" id="status-pill">connecting...</div>
  </div>

  <!-- ===== Dockview Container ===== -->
  <div id="dockview" class="dockview-theme-abyss" style="height: calc(100vh - 44px);"></div>

  <script type="module">
    import { DockviewComponent } from 'dockview-core';

    // =====================================================================
    //  Web Worker (owns WASM instance, all computation off main thread)
    // =====================================================================
    let workerReady = false;
    const computeWorker = new Worker('./worker.js', { type: 'module' });
    computeWorker.onmessage = handleWorkerMessage;

    const workerReadyPromise = new Promise(resolve => {
      const orig = computeWorker.onmessage;
      computeWorker.onmessage = (e) => {
        if (e.data.type === 'ready') { workerReady = true; resolve(); }
        orig(e);
      };
    });

    // =====================================================================
    //  IndexedDB Historical Database Layer
    // =====================================================================
    class VolTerminalDb {
      constructor() { this.db = null; this._opening = null; }
      open() {
        if (this._opening) return this._opening;
        this._opening = new Promise((resolve, reject) => {
          const req = indexedDB.open('vol-terminal-db', 1);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            for (const name of ['vol_snapshots','atm_iv_series','spot_series','realized_vol_series','trade_flow_agg','funding_basis']) {
              if (!db.objectStoreNames.contains(name))
                db.createObjectStore(name, { keyPath: ['currency','timestamp'] });
            }
          };
          req.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
          req.onerror = (e) => { console.error('[idb] open failed:', e); reject(e); };
        });
        return this._opening;
      }
      put(storeName, record) {
        if (!this.db) return;
        try { const tx = this.db.transaction(storeName, 'readwrite'); tx.objectStore(storeName).put(record); } catch (e) { /* fire and forget */ }
      }
      async getRange(storeName, currency, startTs, endTs) {
        if (!this.db) return [];
        return new Promise((resolve) => {
          try {
            const tx = this.db.transaction(storeName, 'readonly');
            const req = tx.objectStore(storeName).getAll(IDBKeyRange.bound([currency, startTs], [currency, endTs]));
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => resolve([]);
          } catch (e) { resolve([]); }
        });
      }
      async pruneOlderThan(storeName, maxAgeMs) {
        if (!this.db) return;
        const cutoff = Date.now() - maxAgeMs;
        try {
          const tx = this.db.transaction(storeName, 'readwrite');
          const req = tx.objectStore(storeName).openCursor();
          req.onsuccess = (e) => {
            const cursor = e.target.result;
            if (!cursor) return;
            if (cursor.value.timestamp < cutoff) cursor.delete();
            cursor.continue();
          };
        } catch (e) { /* ignore */ }
      }
      async pruneAll() {
        const MS30D = 30 * 24 * 60 * 60 * 1000;
        for (const s of ['vol_snapshots','atm_iv_series','spot_series','realized_vol_series','trade_flow_agg','funding_basis'])
          await this.pruneOlderThan(s, MS30D);
      }
    }
    const terminalDb = new VolTerminalDb();

    // =====================================================================
    //  Plotly common layout helpers
    // =====================================================================
    const darkLayout = {
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      font: { color: '#d8e0ea', family: 'IBM Plex Sans, sans-serif', size: 10 },
    };
    const axisStyle = { gridcolor: '#1e2d3d', zerolinecolor: '#1e2d3d', color: '#8ea1b8' };
    const pFmt = new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 });
    const pFmt1 = new Intl.NumberFormat('en-US', { maximumFractionDigits: 1 });

    // =====================================================================
    //  Deribit protocol helpers
    // =====================================================================
    const MONTHS = { JAN:1,FEB:2,MAR:3,APR:4,MAY:5,JUN:6,JUL:7,AUG:8,SEP:9,OCT:10,NOV:11,DEC:12 };

    function parseDeribitExpiry(code) {
      if (code.length !== 7) return null;
      const day = parseInt(code.slice(0, 2), 10);
      const mon = MONTHS[code.slice(2, 5)];
      const yr = 2000 + parseInt(code.slice(5, 7), 10);
      if (!mon || isNaN(day) || isNaN(yr)) return null;
      return new Date(Date.UTC(yr, mon - 1, day, 8, 0, 0));
    }

    function parseInstrumentName(name) {
      const p = name.split('-');
      if (p.length !== 4) return null;
      const expDate = parseDeribitExpiry(p[1]);
      if (!expDate) return null;
      const strike = parseFloat(p[2]);
      if (isNaN(strike)) return null;
      const isCall = p[3] === 'C';
      if (p[3] !== 'C' && p[3] !== 'P') return null;
      return { expiry: p[1], expiryDate: expDate, strike, isCall };
    }

    function normalizeIv(raw) {
      if (!isFinite(raw) || raw <= 0) return NaN;
      return raw > 3.0 ? raw / 100.0 : raw;
    }

    // =====================================================================
    //  Currency State
    // =====================================================================
    const CURRENCY_CONFIG = {
      BTC:       { apiCurrency: 'BTC',  base: 'BTC',  indexName: 'btc_usd',   label: 'BTC',       isLinear: false, prefix: 'BTC-' },
      ETH:       { apiCurrency: 'ETH',  base: 'ETH',  indexName: 'eth_usd',   label: 'ETH',       isLinear: false, prefix: 'ETH-' },
      BTC_USDC:  { apiCurrency: 'USDC', base: 'BTC',  indexName: 'btc_usdc',  label: 'BTC-USDC',  isLinear: true,  prefix: 'BTC_USDC-' },
      ETH_USDC:  { apiCurrency: 'USDC', base: 'ETH',  indexName: 'eth_usdc',  label: 'ETH-USDC',  isLinear: true,  prefix: 'ETH_USDC-' },
      SOL_USDC:  { apiCurrency: 'USDC', base: 'SOL',  indexName: 'sol_usdc',  label: 'SOL-USDC',  isLinear: true,  prefix: 'SOL_USDC-' },
      AVAX_USDC: { apiCurrency: 'USDC', base: 'AVAX', indexName: 'avax_usdc', label: 'AVAX-USDC', isLinear: true,  prefix: 'AVAX_USDC-' },
    };
    let activeCurrency = 'BTC';
    let currencyConfig = CURRENCY_CONFIG[activeCurrency];
    let activeWs = null;
    let intentionalClose = false; // suppress auto-reconnect on currency switch

    // =====================================================================
    //  Market State
    // =====================================================================
    const chain = new Map(); // instrument_name -> quote object
    let spotPrice = 0;
    let dirty = false;
    let tickCount = 0;
    let tickWindowStart = performance.now();
    let ticksPerSec = 0;

    // Previous IV snapshot for vol-change heatmap
    let prevIvMap = new Map(); // "expiry|strike" -> iv

    // Session baseline for surface diff
    let baselineSurface = null;

    // Circular buffers for sparklines
    const SPARK_LEN = 100;
    const spotHistory = [];
    const atmVolHistory = [];

    // Trade flow state
    const tradeFlow = {
      tape: [], sessionVolume: new Map(), callVolume: 0, putVolume: 0,
      totalNotional: 0, largeTrades: [], lastNotionals: [],
    };
    let tradeFlowDirty = false, tradeFlowRafPending = false;

    // Funding state
    const fundingState = { currentRate: NaN, perpPrice: NaN, indexPrice: NaN, history: [] };

    // Vol cone state
    let volConeLookback = 90;
    let historicalVolData = null;

    // Strategy state
    const strategyLegs = [];
    let lastStrategyResult = null;
    let lastForwardVolData = null;

    // =====================================================================
    //  View Mode System
    // =====================================================================
    const VIEW_DEFS = {
      overview: {
        panels: ['surface', 'term', 'smile', 'scanner'],
        build(dv) {
          dv.addPanel({ id: 'surface', component: 'surface', title: '3D Vol Surface' });
          dv.addPanel({ id: 'term', component: 'term', title: 'Term Structure',
            position: { referencePanel: 'surface', direction: 'right' } });
          dv.addPanel({ id: 'smile', component: 'smile', title: 'Smile Slice',
            position: { referencePanel: 'term', direction: 'below' } });
          dv.addPanel({ id: 'scanner', component: 'scanner', title: 'Mispricing Scanner',
            position: { referencePanel: 'surface', direction: 'below' } });
        },
      },
      analysis: {
        panels: ['greeks', 'forwardvol', 'volcone', 'volchange'],
        build(dv) {
          dv.addPanel({ id: 'greeks', component: 'greeks', title: 'Greeks Heatmap' });
          dv.addPanel({ id: 'forwardvol', component: 'forwardvol', title: 'Forward Vol',
            position: { referencePanel: 'greeks', direction: 'right' } });
          dv.addPanel({ id: 'volcone', component: 'volcone', title: 'Vol Cone',
            position: { referencePanel: 'greeks', direction: 'below' } });
          dv.addPanel({ id: 'volchange', component: 'volchange', title: 'IV Change Heatmap',
            position: { referencePanel: 'forwardvol', direction: 'below' } });
        },
      },
      scanner: {
        panels: ['scanner', 'metrics', 'smile'],
        build(dv) {
          dv.addPanel({ id: 'scanner', component: 'scanner', title: 'Mispricing Scanner' });
          dv.addPanel({ id: 'metrics', component: 'metrics', title: 'Metrics & Skew',
            position: { referencePanel: 'scanner', direction: 'right' } });
          dv.addPanel({ id: 'smile', component: 'smile', title: 'Smile Slice',
            position: { referencePanel: 'metrics', direction: 'below' } });
        },
      },
      trading: {
        panels: ['tradeflow', 'strategy', 'funding'],
        build(dv) {
          dv.addPanel({ id: 'tradeflow', component: 'tradeflow', title: 'Trade Flow' });
          dv.addPanel({ id: 'strategy', component: 'strategy', title: 'Strategy Builder',
            position: { referencePanel: 'tradeflow', direction: 'right' } });
          dv.addPanel({ id: 'funding', component: 'funding', title: 'Funding & Basis',
            position: { referencePanel: 'tradeflow', direction: 'below' } });
        },
      },
      all: {
        panels: ['surface','volchange','smile','greeks','term','forwardvol','metrics','funding','volcone','scanner','tradeflow','strategy'],
        build: null, // uses createDefaultLayout
      },
    };
    let activeView = 'overview';
    const LAYOUT_KEY_PREFIX = 'vol-terminal-layout-';

    // IndexedDB snapshot timers
    const lastDbWrite = { vol_snapshots: 0, atm_iv_series: 0, spot_series: 0, realized_vol_series: 0, trade_flow_agg: 0, funding_basis: 0 };

    function noteQuote(name, q) {
      chain.set(name, q);
      dirty = true;
      tickCount++;
    }

    function refreshTps() {
      const elapsed = (performance.now() - tickWindowStart) / 1000;
      if (elapsed >= 1.0) {
        ticksPerSec = tickCount / elapsed;
        tickCount = 0;
        tickWindowStart = performance.now();
      }
    }

    // =====================================================================
    //  Active model selection
    // =====================================================================
    let activeModel = 'svi'; // 'svi' | 'sabr' | 'vv'

    document.getElementById('model-select').addEventListener('change', (e) => {
      activeModel = e.target.value;
      dirty = true;
      baselineSurface = null; // reset baseline on model switch
      calibratedSlices = [];
      lastSurfaceData = null;
      lastGreeksData = null;
      lastScannerData = null;
      lastForwardVolData = null;
      surfaceInitialized = false;
      // Purge all Plotly charts so panels show blank until new model results arrive
      for (const key of Object.keys(panels)) {
        const p = panels[key];
        if (p && p.chartDiv) Plotly.purge(p.chartDiv);
        if (p && p.heatDiv) Plotly.purge(p.heatDiv);
        if (p && p.heatmapDiv) Plotly.purge(p.heatmapDiv);
      }
      if (computeWorker) computeWorker.postMessage({ type: 'config-update', payload: { activeModel } });
      scheduleCalibration();
    });

    // =====================================================================
    //  Currency switching
    // =====================================================================
    function switchCurrency(newCurrency) {
      if (newCurrency === activeCurrency) return;
      activeCurrency = newCurrency;
      currencyConfig = CURRENCY_CONFIG[activeCurrency];

      // Close existing WebSocket (suppress auto-reconnect)
      intentionalClose = true;
      if (activeWs) { activeWs.close(); activeWs = null; }

      // Clear all market state
      chain.clear();
      spotPrice = 0;
      dirty = false;
      tickCount = 0;
      calibratedSlices = [];
      prevIvMap = new Map();
      baselineSurface = null;
      spotHistory.length = 0;
      atmVolHistory.length = 0;
      activeExpiry = '';
      surfaceInitialized = false;
      lastForwardVolData = null;
      lastStrategyResult = null;
      historicalVolData = null;
      tradeFlow.tape.length = 0; tradeFlow.sessionVolume.clear(); tradeFlow.callVolume = 0;
      tradeFlow.putVolume = 0; tradeFlow.totalNotional = 0; tradeFlow.largeTrades.length = 0;
      tradeFlow.lastNotionals.length = 0;
      fundingState.currentRate = NaN; fundingState.perpPrice = NaN;
      fundingState.indexPrice = NaN; fundingState.history.length = 0;
      strategyLegs.length = 0;

      // Purge all Plotly charts so they reinitialize cleanly
      for (const key of Object.keys(panels)) {
        const p = panels[key];
        if (p && p.chartDiv) Plotly.purge(p.chartDiv);
        if (p && p.heatDiv) Plotly.purge(p.heatDiv);
        if (p && p.heatmapDiv) Plotly.purge(p.heatmapDiv);
      }

      // Update page title and header
      document.title = currencyConfig.label + ' Options Vol Terminal';
      document.querySelector('.header-title').textContent = currencyConfig.label + ' Options Vol Terminal';
      document.getElementById('hdr-spot').textContent = '--';

      // Notify worker of reset
      if (computeWorker) computeWorker.postMessage({ type: 'config-update', payload: { activeModel, isLinear: currencyConfig.isLinear } });

      // Re-seed and reconnect
      seedFromRest();
      connectWs();
      fetchFundingHistory();
      fetchHistoricalVol();
    }

    document.getElementById('currency-select').addEventListener('change', (e) => {
      switchCurrency(e.target.value);
    });

    // =====================================================================
    //  Calibration (per-expiry, model-aware)
    // =====================================================================
    let calibrationScheduled = false;
    let lastCalibTime = 0;
    let calibTimeUs = 0;
    let calibratedSlices = []; // sorted by T
    let activeExpiry = '';
    let activeGreek = 'delta';

    function scheduleCalibration() {
      if (calibrationScheduled) return;
      calibrationScheduled = true;
      setTimeout(runCalibration, 1000);
    }

    function runCalibration() {
      calibrationScheduled = false;
      if (!dirty || !workerReady) {
        if (dirty && !workerReady) setTimeout(runCalibration, 100);
        return;
      }
      dirty = false;
      renderCycle++;

      // Update spot history (main thread — needs DOM timing)
      if (spotPrice > 0) {
        spotHistory.push(spotPrice);
        if (spotHistory.length > SPARK_LEN) spotHistory.shift();
      }

      const chainEntries = Array.from(chain.entries()).map(([n, q]) => [n, { ...q }]);
      computeWorker.postMessage({
        type: 'market-update',
        payload: { chainEntries, spotPrice, spotHistory: [...spotHistory], renderCycle },
      });
    }

    // (All math functions removed — running in Rust/WASM via batch calls)

    // =====================================================================
    //  Sparkline SVG renderer
    // =====================================================================
    function renderSparkline(svgEl, data, color) {
      if (data.length < 2) { svgEl.innerHTML = ''; return; }
      const w = 80, h = 22, pad = 2;
      let min = Infinity, max = -Infinity;
      for (const v of data) {
        if (v < min) min = v;
        if (v > max) max = v;
      }
      if (max - min < 1e-10) { max = min + 1; }
      const pts = data.map((v, i) => {
        const x = pad + (i / (data.length - 1)) * (w - 2 * pad);
        const y = h - pad - ((v - min) / (max - min)) * (h - 2 * pad);
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).join(' ');
      svgEl.innerHTML = `<polyline points="${pts}" fill="none" stroke="${color}" stroke-width="1.2" stroke-linejoin="round"/>`;
    }

    // =====================================================================
    //  Panel Component Classes (Dockview vanilla API)
    // =====================================================================
    const panels = {};

    class SurfacePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">3D Vol Surface (SVI fit + market)</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.titleEl = this._el.querySelector('.panel-title');
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.surface = this;
        surfaceInitialized = false;
        zoomTarget = null;
        zoomCurrent = null;
        if (zoomRafId) { cancelAnimationFrame(zoomRafId); zoomRafId = null; }
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.surface;
      }
    }

    class VolChangePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">IV Change Heatmap</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.volchange = this;
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.volchange;
      }
    }

    class SmilePanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Smile Slice</div>'
          + '<div class="toolbar">'
          + '<label>expiry</label>'
          + '<select class="expiry-select"></select>'
          + '</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.expirySelect = this._el.querySelector('.expiry-select');
        panels.smile = this;
        this.expirySelect.addEventListener('change', (e) => {
          activeExpiry = e.target.value;
          renderSmile();
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.smile;
      }
    }

    class GreeksPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Greeks Heatmap</div>'
          + '<div class="toolbar greeks-tabs">'
          + '<button class="tab-btn active" data-greek="delta">Delta</button>'
          + '<button class="tab-btn" data-greek="gamma">Gamma</button>'
          + '<button class="tab-btn" data-greek="vega">Vega</button>'
          + '<button class="tab-btn" data-greek="theta">Theta</button>'
          + '</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.tabContainer = this._el.querySelector('.greeks-tabs');
        panels.greeks = this;
        this.tabContainer.addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn');
          if (!btn) return;
          this.tabContainer.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          activeGreek = btn.dataset.greek;
          if (computeWorker) computeWorker.postMessage({ type: 'config-update', payload: { activeGreek } });
          // Force recompute greeks on next cycle
          dirty = true;
          scheduleCalibration();
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.greeks;
      }
    }

    class TermPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Term Structure (ATM + RR25 + BF25)</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        panels.term = this;
        this._resizeObs = new ResizeObserver(() => {
          if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.term;
      }
    }

    class MetricsPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Metrics &amp; Skew</div>'
          + '</div>'
          + '<div class="metrics-grid">'
          + '<div class="k">spot</div><div class="v m-spot">--</div>'
          + '<div class="k">options</div><div class="v m-options">--</div>'
          + '<div class="k">expiries</div><div class="v m-expiries">--</div>'
          + '<div class="k">ticks/sec</div><div class="v m-tps">--</div>'
          + '<div class="k">calib (us)</div><div class="v m-calib">--</div>'
          + '<div class="k">realized vol</div><div class="v m-rvol">--</div>'
          + '</div>'
          + '<div class="tbl-wrap">'
          + '<table>'
          + '<thead><tr><th>expiry</th><th>ATM</th><th>RMSE</th><th>skew</th><th>kurt</th><th>RR25</th><th>BF25</th><th>n</th></tr></thead>'
          + '<tbody></tbody>'
          + '</table>'
          + '</div>';
        this.mSpot = this._el.querySelector('.m-spot');
        this.mOptions = this._el.querySelector('.m-options');
        this.mExpiries = this._el.querySelector('.m-expiries');
        this.mTps = this._el.querySelector('.m-tps');
        this.mCalib = this._el.querySelector('.m-calib');
        this.mRvol = this._el.querySelector('.m-rvol');
        this.skewTbody = this._el.querySelector('tbody');
        panels.metrics = this;
      }
      dispose() { delete panels.metrics; }
    }

    class ScannerPanel {
      constructor() {
        this._el = document.createElement('div');
        this._el.className = 'dock-content';
      }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Mispricing Scanner</div>'
          + '<div class="toolbar">'
          + '<label>min edge</label>'
          + '<select class="edge-threshold">'
          + '<option value="0.5">0.5 vol</option>'
          + '<option value="1.0" selected>1.0 vol</option>'
          + '<option value="2.0">2.0 vol</option>'
          + '<option value="5.0">5.0 vol</option>'
          + '</select>'
          + '<label>min maturity</label>'
          + '<select class="min-maturity">'
          + '<option value="0" selected>all</option>'
          + '<option value="7">7d</option>'
          + '<option value="14">14d</option>'
          + '<option value="30">30d</option>'
          + '<option value="60">60d</option>'
          + '<option value="90">90d</option>'
          + '</select>'
          + '<label>side</label>'
          + '<select class="edge-side">'
          + '<option value="all" selected>all</option>'
          + '<option value="buy">buy only</option>'
          + '<option value="sell">sell only</option>'
          + '</select>'
          + '</div>'
          + '</div>'
          + '<div class="scanner-wrap">'
          + '<div class="scanner-heatmap"></div>'
          + '<div class="scanner-table-wrap">'
          + '<table>'
          + '<thead><tr>'
          + '<th>expiry</th><th>strike</th><th>C/P</th>'
          + '<th>mkt IV</th><th>mdl IV</th><th>IV edge</th>'
          + '<th>bid</th><th>ask</th><th>mid</th><th>theo</th>'
          + '<th>$ edge</th><th>signal</th>'
          + '</tr></thead>'
          + '<tbody></tbody>'
          + '</table>'
          + '</div>'
          + '</div>';
        this.heatmapDiv = this._el.querySelector('.scanner-heatmap');
        this.edgeTbody = this._el.querySelector('.scanner-table-wrap tbody');
        panels.scanner = this;
        this._el.querySelector('.edge-threshold').addEventListener('change', (e) => {
          edgeThreshold = parseFloat(e.target.value);
          if (computeWorker) computeWorker.postMessage({ type: 'config-update', payload: { edgeThreshold } });
          // Re-render from cached data or trigger recompute
          if (lastScannerData) renderScanner(lastScannerData);
          else renderScanner();
        });
        this._el.querySelector('.edge-side').addEventListener('change', (e) => {
          edgeSideFilter = e.target.value;
          if (computeWorker) computeWorker.postMessage({ type: 'config-update', payload: { edgeSideFilter } });
          if (lastScannerData) renderScanner(lastScannerData);
          else renderScanner();
        });
        this._el.querySelector('.min-maturity').addEventListener('change', (e) => {
          minMaturity = parseFloat(e.target.value);
          if (lastScannerData) renderScanner(lastScannerData);
        });
        this._resizeObs = new ResizeObserver(() => {
          if (this.heatmapDiv && this.heatmapDiv.data) Plotly.Plots.resize(this.heatmapDiv);
        });
        this._resizeObs.observe(this._el);
      }
      dispose() {
        if (this._resizeObs) this._resizeObs.disconnect();
        delete panels.scanner;
      }
    }

    class ForwardVolPanel {
      constructor() { this._el = document.createElement('div'); this._el.className = 'dock-content'; }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Forward Volatility</div>'
          + '<div class="toolbar">'
          + '<button class="tab-btn active" data-tab="term">Term</button>'
          + '<button class="tab-btn" data-tab="skew">Skew</button>'
          + '</div></div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.activeTab = 'term';
        panels.forwardvol = this;
        this._el.querySelector('.toolbar').addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn'); if (!btn) return;
          this._el.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active'); this.activeTab = btn.dataset.tab; renderForwardVol();
        });
        this._resizeObs = new ResizeObserver(() => { if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv); });
        this._resizeObs.observe(this._el);
      }
      dispose() { if (this._resizeObs) this._resizeObs.disconnect(); delete panels.forwardvol; }
    }

    class FundingBasisPanel {
      constructor() { this._el = document.createElement('div'); this._el.className = 'dock-content'; }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Funding &amp; Basis</div>'
          + '<div class="toolbar">'
          + '<button class="tab-btn active" data-tab="funding">Funding</button>'
          + '<button class="tab-btn" data-tab="basis">Basis</button>'
          + '<button class="tab-btn" data-tab="carry">Carry</button>'
          + '</div></div>'
          + '<div class="funding-metrics">'
          + '<div class="k">funding rate</div><div class="v f-rate">--</div>'
          + '<div class="k">perp price</div><div class="v f-perp">--</div>'
          + '<div class="k">index price</div><div class="v f-index">--</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.activeTab = 'funding';
        this.fRate = this._el.querySelector('.f-rate');
        this.fPerp = this._el.querySelector('.f-perp');
        this.fIndex = this._el.querySelector('.f-index');
        panels.funding = this;
        this._el.querySelector('.toolbar').addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn'); if (!btn) return;
          this._el.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active'); this.activeTab = btn.dataset.tab; renderFunding();
        });
        this._resizeObs = new ResizeObserver(() => { if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv); });
        this._resizeObs.observe(this._el);
      }
      dispose() { if (this._resizeObs) this._resizeObs.disconnect(); delete panels.funding; }
    }

    class TradeFlowPanel {
      constructor() { this._el = document.createElement('div'); this._el.className = 'dock-content'; }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Trade Flow</div>'
          + '<div class="toolbar">'
          + '<button class="tab-btn active" data-tab="tape">Tape</button>'
          + '<button class="tab-btn" data-tab="heatmap">Heatmap</button>'
          + '<button class="tab-btn" data-tab="large">Large</button>'
          + '</div></div>'
          + '<div class="flow-metrics">'
          + '<div class="k">P/C ratio</div><div class="v tf-pcr">--</div>'
          + '<div class="k">session vol</div><div class="v tf-vol">--</div>'
          + '<div class="k">notional</div><div class="v tf-notional">--</div>'
          + '</div>'
          + '<div class="tape-wrap" data-tab-content="tape">'
          + '<table><thead><tr><th>time</th><th>instrument</th><th>side</th><th>qty</th><th>price</th><th>IV</th></tr></thead><tbody></tbody></table>'
          + '</div>'
          + '<div class="chart-area" data-tab-content="heatmap" style="display:none"></div>'
          + '<div class="tape-wrap" data-tab-content="large" style="display:none">'
          + '<table><thead><tr><th>time</th><th>instrument</th><th>side</th><th>qty</th><th>price</th><th>IV</th><th>notional</th></tr></thead><tbody></tbody></table>'
          + '</div>';
        this.tapeTbody = this._el.querySelector('[data-tab-content="tape"] tbody');
        this.heatmapDiv = this._el.querySelector('[data-tab-content="heatmap"]');
        this.largeTbody = this._el.querySelector('[data-tab-content="large"] tbody');
        this.tfPcr = this._el.querySelector('.tf-pcr');
        this.tfVol = this._el.querySelector('.tf-vol');
        this.tfNotional = this._el.querySelector('.tf-notional');
        this.activeTab = 'tape';
        panels.tradeflow = this;
        this._el.querySelector('.toolbar').addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn'); if (!btn) return;
          this._el.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active'); this.activeTab = btn.dataset.tab;
          this._el.querySelectorAll('[data-tab-content]').forEach(el => {
            el.style.display = el.dataset.tabContent === this.activeTab ? '' : 'none';
          });
          renderTradeFlow();
        });
        this._resizeObs = new ResizeObserver(() => { if (this.heatmapDiv && this.heatmapDiv.data) Plotly.Plots.resize(this.heatmapDiv); });
        this._resizeObs.observe(this._el);
      }
      dispose() { if (this._resizeObs) this._resizeObs.disconnect(); delete panels.tradeflow; }
    }

    class VolConePanel {
      constructor() { this._el = document.createElement('div'); this._el.className = 'dock-content'; }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Vol Cone &amp; IV Rank</div>'
          + '<div class="toolbar">'
          + '<label>lookback</label>'
          + '<select class="volcone-lookback">'
          + '<option value="30">30d</option><option value="90" selected>90d</option>'
          + '<option value="180">180d</option><option value="365">1y</option>'
          + '</select></div></div>'
          + '<div class="volcone-metrics">'
          + '<div class="k">IV Rank</div><div class="v vc-ivrank">--</div>'
          + '<div class="k">IV Pctl</div><div class="v vc-ivpctl">--</div>'
          + '<div class="k">ATM IV</div><div class="v vc-atmiv">--</div>'
          + '<div class="k">30d RVol</div><div class="v vc-rvol">--</div>'
          + '</div>'
          + '<div class="chart-area"></div>';
        this.chartDiv = this._el.querySelector('.chart-area');
        this.vcIvrank = this._el.querySelector('.vc-ivrank');
        this.vcIvpctl = this._el.querySelector('.vc-ivpctl');
        this.vcAtmiv = this._el.querySelector('.vc-atmiv');
        this.vcRvol = this._el.querySelector('.vc-rvol');
        panels.volcone = this;
        this._el.querySelector('.volcone-lookback').addEventListener('change', (e) => {
          volConeLookback = parseInt(e.target.value); fetchHistoricalVol();
        });
        this._resizeObs = new ResizeObserver(() => { if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv); });
        this._resizeObs.observe(this._el);
        fetchHistoricalVol();
      }
      dispose() { if (this._resizeObs) this._resizeObs.disconnect(); delete panels.volcone; }
    }

    class StrategyPanel {
      constructor() { this._el = document.createElement('div'); this._el.className = 'dock-content'; }
      get element() { return this._el; }
      init(params) {
        this._el.innerHTML =
          '<div class="panel-head">'
          + '<div class="panel-title">Strategy Builder</div>'
          + '<div class="toolbar">'
          + '<button class="tab-btn" data-action="add-leg">+ Leg</button>'
          + '<button class="tab-btn" data-action="clear">Clear</button>'
          + '</div></div>'
          + '<div class="template-btns">'
          + '<button class="tab-btn" data-tmpl="straddle">Straddle</button>'
          + '<button class="tab-btn" data-tmpl="strangle">Strangle</button>'
          + '<button class="tab-btn" data-tmpl="bull-call">Bull Call</button>'
          + '<button class="tab-btn" data-tmpl="bear-put">Bear Put</button>'
          + '<button class="tab-btn" data-tmpl="iron-condor">Iron Condor</button>'
          + '<button class="tab-btn" data-tmpl="butterfly">Butterfly</button>'
          + '</div>'
          + '<div class="strategy-split">'
          + '<div class="strategy-legs">'
          + '<table><thead><tr><th>C/P</th><th>strike</th><th>expiry</th><th>qty</th><th>IV</th><th>price</th><th></th></tr></thead><tbody></tbody></table>'
          + '<div class="net-greeks">'
          + '<div class="k">delta</div><div class="v sg-delta">--</div>'
          + '<div class="k">gamma</div><div class="v sg-gamma">--</div>'
          + '<div class="k">vega</div><div class="v sg-vega">--</div>'
          + '<div class="k">theta</div><div class="v sg-theta">--</div>'
          + '</div></div>'
          + '<div class="strategy-chart">'
          + '<div class="chart-area"></div>'
          + '<div class="slider-row"><span>spot</span><input type="range" class="sl-spot" min="-30" max="30" value="0" step="1"><span class="slider-val sl-spot-val">0%</span></div>'
          + '<div class="slider-row"><span>vol</span><input type="range" class="sl-vol" min="-20" max="20" value="0" step="1"><span class="slider-val sl-vol-val">0</span></div>'
          + '<div class="slider-row"><span>time</span><input type="range" class="sl-time" min="-30" max="0" value="0" step="1"><span class="slider-val sl-time-val">0d</span></div>'
          + '</div></div>';
        this.chartDiv = this._el.querySelector('.strategy-chart .chart-area');
        this.legsTbody = this._el.querySelector('.strategy-legs tbody');
        this.sgDelta = this._el.querySelector('.sg-delta');
        this.sgGamma = this._el.querySelector('.sg-gamma');
        this.sgVega = this._el.querySelector('.sg-vega');
        this.sgTheta = this._el.querySelector('.sg-theta');
        this.slSpot = this._el.querySelector('.sl-spot');
        this.slVol = this._el.querySelector('.sl-vol');
        this.slTime = this._el.querySelector('.sl-time');
        this.slSpotVal = this._el.querySelector('.sl-spot-val');
        this.slVolVal = this._el.querySelector('.sl-vol-val');
        this.slTimeVal = this._el.querySelector('.sl-time-val');
        panels.strategy = this;
        this._el.querySelector('.template-btns').addEventListener('click', (e) => {
          const btn = e.target.closest('[data-tmpl]'); if (!btn) return;
          applyStrategyTemplate(btn.dataset.tmpl);
        });
        this._el.querySelector('.toolbar').addEventListener('click', (e) => {
          const btn = e.target.closest('[data-action]'); if (!btn) return;
          if (btn.dataset.action === 'add-leg') addStrategyLeg();
          if (btn.dataset.action === 'clear') { strategyLegs.length = 0; renderStrategyLegs(); triggerStrategyCompute(); }
        });
        const onSlider = () => {
          this.slSpotVal.textContent = this.slSpot.value + '%';
          this.slVolVal.textContent = this.slVol.value;
          this.slTimeVal.textContent = this.slTime.value + 'd';
          triggerStrategyCompute();
        };
        this.slSpot.addEventListener('input', onSlider);
        this.slVol.addEventListener('input', onSlider);
        this.slTime.addEventListener('input', onSlider);
        this._resizeObs = new ResizeObserver(() => { if (this.chartDiv && this.chartDiv.data) Plotly.Plots.resize(this.chartDiv); });
        this._resizeObs.observe(this._el);
      }
      dispose() { if (this._resizeObs) this._resizeObs.disconnect(); delete panels.strategy; }
    }

    // =====================================================================
    //  Render cycle counter (tiering is done in the worker)
    // =====================================================================
    let renderCycle = 0;
    let frameCache = null; // populated from worker results

    // =====================================================================
    //  Worker message handler + result application
    // =====================================================================
    let lastSurfaceData = null, lastGreeksData = null, lastScannerData = null;

    function handleWorkerMessage(e) {
      if (e.data.type === 'ready') {
        workerReady = true;
        console.log('[worker] ready');
        return;
      }
      if (e.data.type === 'compute-result') {
        applyComputeResult(e.data.payload);
      }
      if (e.data.type === 'strategy-result') {
        lastStrategyResult = e.data.payload;
        requestAnimationFrame(() => renderStrategyPayoff(e.data.payload));
      }
    }

    function applyComputeResult(r) {
      calibratedSlices = r.calibratedSlices;
      calibTimeUs = r.calibTimeUs;

      // Update surface title
      const modelNames = { svi: 'SVI', sabr: 'SABR', vv: 'Vanna-Volga' };
      if (panels.surface && panels.surface.titleEl) {
        const mt = calibratedSlices.length > 0 ? calibratedSlices[0].modelType : activeModel;
        panels.surface.titleEl.textContent =
          `3D Vol Surface (${modelNames[mt] || mt} fit + market)`;
      }

      // Save previous IVs for heatmap diff
      const newIvMap = new Map();
      for (const sl of calibratedSlices) {
        for (const pt of sl.points) {
          newIvMap.set(sl.expiryCode + '|' + pt.strike, pt.market_iv);
        }
      }
      if (!baselineSurface) baselineSurface = calibratedSlices;

      // Update ATM vol sparkline
      const globalAtm = calibratedSlices.length > 0 ? calibratedSlices[0].atmVol : NaN;
      if (isFinite(globalAtm)) {
        atmVolHistory.push(globalAtm);
        if (atmVolHistory.length > SPARK_LEN) atmVolHistory.shift();
      }
      prevIvMap = newIvMap;

      // Cache tiered data
      if (r.surface) lastSurfaceData = r.surface;
      if (r.greeks) lastGreeksData = r.greeks;
      if (r.scanner) lastScannerData = r.scanner;

      // Store frame cache data from worker for metrics/term fallback
      frameCache = (r.d25 && r.atmIv) ? {
        packed: null,
        d25: r.d25,
        atmIv: r.atmIv,
        termRr25: r.termRr25 || [],
        termBf25: r.termBf25 || [],
        realizedVol: r.realizedVol,
      } : null;

      // Cache forward vol data
      if (r.forwardVol) lastForwardVolData = r.forwardVol;

      // IndexedDB snapshot writes (fire-and-forget)
      const now = Date.now();
      if (now - lastDbWrite.atm_iv_series > 60000 && calibratedSlices.length > 0) {
        lastDbWrite.atm_iv_series = now;
        for (const sl of calibratedSlices) terminalDb.put('atm_iv_series', { currency: activeCurrency, timestamp: now, expiry: sl.expiryCode, atmIv: sl.atmVol });
      }
      if (now - lastDbWrite.spot_series > 60000 && spotPrice > 0) {
        lastDbWrite.spot_series = now;
        terminalDb.put('spot_series', { currency: activeCurrency, timestamp: now, spot: spotPrice });
      }
      if (now - lastDbWrite.vol_snapshots > 300000 && calibratedSlices.length > 0) {
        lastDbWrite.vol_snapshots = now;
        terminalDb.put('vol_snapshots', { currency: activeCurrency, timestamp: now, slices: calibratedSlices.map(s => ({ expiry: s.expiryCode, T: s.T, atmVol: s.atmVol, modelType: s.modelType, params: s.params })) });
      }

      requestAnimationFrame(() => {
        refreshTps();
        renderHeader();
        renderMetrics(r);
        renderSmile();
        renderTerm(r);
        renderVolChange();
        if (lastGreeksData) renderGreeks(lastGreeksData);
        if (lastScannerData) renderScanner(lastScannerData);
        if (lastSurfaceData) renderSurface(lastSurfaceData);
        if (lastForwardVolData) renderForwardVol();
        renderFunding();
        renderVolCone();
      });
    }

    function renderHeader() {
      document.getElementById('hdr-spot').textContent = spotPrice > 0 ? '$' + pFmt.format(spotPrice) : '--';
      renderSparkline(document.getElementById('spark-spot'), spotHistory, '#2fb2ff');
      renderSparkline(document.getElementById('spark-vol'), atmVolHistory, '#19d8a8');
    }

    // --- 3D Surface ---
    let surfaceInitialized = false;
    let surfaceInteracting = false;
    let surfaceDirty = false;

    // Smooth zoom state
    let zoomTarget = null;   // {x, y, z} target eye position
    let zoomCurrent = null;  // {x, y, z} current animated eye
    let zoomRafId = null;
    const ZOOM_LERP = 0.15;  // interpolation factor per frame (0-1, higher = snappier)
    const ZOOM_STEP = 0.08;  // distance factor per wheel tick

    function animateZoom(div) {
      if (!zoomTarget || !zoomCurrent) return;
      // Lerp toward target
      zoomCurrent.x += (zoomTarget.x - zoomCurrent.x) * ZOOM_LERP;
      zoomCurrent.y += (zoomTarget.y - zoomCurrent.y) * ZOOM_LERP;
      zoomCurrent.z += (zoomTarget.z - zoomCurrent.z) * ZOOM_LERP;

      Plotly.relayout(div, {
        'scene.camera.eye': { x: zoomCurrent.x, y: zoomCurrent.y, z: zoomCurrent.z }
      });

      // Keep animating until close enough
      const dx = zoomTarget.x - zoomCurrent.x;
      const dy = zoomTarget.y - zoomCurrent.y;
      const dz = zoomTarget.z - zoomCurrent.z;
      if (dx * dx + dy * dy + dz * dz > 1e-8) {
        zoomRafId = requestAnimationFrame(() => animateZoom(div));
      } else {
        zoomCurrent.x = zoomTarget.x;
        zoomCurrent.y = zoomTarget.y;
        zoomCurrent.z = zoomTarget.z;
        zoomRafId = null;
        // End interaction after animation settles
        surfaceInteracting = false;
        if (surfaceDirty) { surfaceDirty = false; renderSurface(lastSurfaceData); }
      }
    }

    // --- 3D Surface ---
    function renderSurface(data) {
      const div = panels.surface ? panels.surface.chartDiv : null;
      if (!div || !data) return;

      if (surfaceInteracting && surfaceInitialized) {
        surfaceDirty = true;
        document.getElementById('calib-time').textContent = calibTimeUs > 0 ? calibTimeUs + ' us' : '';
        return;
      }

      const { kGrid, tGrid, flatZ, gridN, marketX, marketY, marketZ, marketText } = data;
      const zGrid = [];
      const nSlices = tGrid.length;
      for (let i = 0; i < nSlices; i++) {
        zGrid.push(flatZ.slice(i * gridN, (i + 1) * gridN));
      }

      if (!surfaceInitialized) {
        const traces = [
          {
            type: 'surface', name: 'Fitted', x: kGrid, y: tGrid, z: zGrid,
            opacity: 0.82, showscale: false,
            colorscale: [[0,'#144f83'],[0.5,'#1e8ac8'],[1,'#39dba7']],
          },
          {
            type: 'scatter3d', mode: 'markers', name: 'Market',
            x: marketX, y: marketY, z: marketZ,
            text: marketText,
            hovertemplate: '%{text}<extra></extra>',
            marker: { size: 2.2, color: '#d8e0ea', opacity: 0.85 },
          },
        ];

        const layout = {
          ...darkLayout,
          uirevision: 'stable',
          margin: { l: 0, r: 0, b: 0, t: 0 },
          scene: {
            xaxis: { title: 'ln(K/F)', ...axisStyle },
            yaxis: { title: 'T (yr)', ...axisStyle },
            zaxis: { title: 'IV (%)', ...axisStyle },
            camera: { eye: { x: 1.65, y: 1.25, z: 0.8 } },
          },
          showlegend: false,
        };

        Plotly.newPlot(div, traces, layout, { responsive: true, displayModeBar: false, scrollZoom: false });
        surfaceInitialized = true;

        div.addEventListener('mousedown', () => { surfaceInteracting = true; });
        window.addEventListener('mouseup', () => {
          if (surfaceInteracting && !zoomRafId) {
            surfaceInteracting = false;
            if (surfaceDirty) { surfaceDirty = false; renderSurface(lastSurfaceData); }
          }
        });

        div.addEventListener('wheel', (e) => {
          e.preventDefault();
          surfaceInteracting = true;
          const scene = div._fullLayout && div._fullLayout.scene;
          const cam = scene && scene._scene ? scene._scene.getCamera() : null;
          const eye = cam ? cam.eye : (zoomCurrent || { x: 1.65, y: 1.25, z: 0.8 });
          if (!zoomCurrent) zoomCurrent = { x: eye.x, y: eye.y, z: eye.z };
          const base = zoomTarget || { x: eye.x, y: eye.y, z: eye.z };
          const direction = e.deltaY > 0 ? 1 : -1;
          const scale = 1 + direction * ZOOM_STEP;
          zoomTarget = { x: base.x * scale, y: base.y * scale, z: base.z * scale };
          if (!zoomRafId) {
            zoomRafId = requestAnimationFrame(() => animateZoom(div));
          }
        }, { passive: false });
      } else {
        Plotly.restyle(div,
          { x: [kGrid, marketX], y: [tGrid, marketY], z: [zGrid, marketZ], text: [null, marketText] },
          [0, 1]);
      }

      surfaceDirty = false;
      document.getElementById('calib-time').textContent = calibTimeUs > 0 ? calibTimeUs + ' us' : '';
    }

    // --- Vol Change Heatmap ---
    function renderVolChange() {
      const div = panels.volchange ? panels.volchange.chartDiv : null;
      if (!div) return;
      if (calibratedSlices.length === 0) return;

      const expLabels = [];
      const strikeSet = new Set();
      for (const sl of calibratedSlices) {
        expLabels.push(sl.expiryLabel);
        for (const pt of sl.points) strikeSet.add(pt.strike);
      }
      const strikes = [...strikeSet].sort((a, b) => a - b);
      // Subsample if too many strikes
      const maxStrikes = 30;
      const step = strikes.length > maxStrikes ? Math.ceil(strikes.length / maxStrikes) : 1;
      const sampledStrikes = strikes.filter((_, i) => i % step === 0);

      const z = [];
      for (const sl of calibratedSlices) {
        const row = [];
        const ptMap = new Map();
        for (const pt of sl.points) ptMap.set(pt.strike, pt.market_iv);
        for (const strike of sampledStrikes) {
          const curIv = ptMap.get(strike);
          const prevIv = prevIvMap.get(sl.expiryCode + '|' + strike);
          if (curIv !== undefined && prevIv !== undefined) {
            row.push(curIv - prevIv);
          } else {
            row.push(0);
          }
        }
        z.push(row);
      }

      Plotly.react(div, [{
        type: 'heatmap', x: sampledStrikes.map(s => pFmt.format(s)),
        y: expLabels, z, colorscale: [[0,'#2255bb'],[0.5,'#1a1a2e'],[1,'#bb2222']],
        showscale: true, colorbar: { title: 'IV chg', titleside: 'right', thickness: 10, len: 0.6 },
        zmin: -2, zmax: 2,
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Smile Slice ---
    function renderSmile() {
      const div = panels.smile ? panels.smile.chartDiv : null;
      if (!div) return;
      ensureExpirySelection();
      if (!activeExpiry || calibratedSlices.length === 0) return;

      const slice = calibratedSlices.find(s => s.expiryCode === activeExpiry);
      if (!slice) return;

      const pts = slice.points;
      const x = pts.map(p => p.k); // pre-computed in WASM (calibrate_slice_wasm)
      const marketIv = pts.map(p => p.market_iv);
      const fittedIv = pts.map(p => p.fitted_iv);
      const bidIv = pts.map(p => p.bid_iv);
      const askIv = pts.map(p => p.ask_iv);

      const traces = [];

      // Bid-ask ribbon (only if we have valid bid/ask)
      const hasBidAsk = bidIv.some(v => v > 0) && askIv.some(v => v > 0);
      if (hasBidAsk) {
        traces.push({
          type: 'scatter', mode: 'lines', name: 'bid IV', x, y: bidIv,
          line: { color: 'rgba(47,178,255,0.3)', width: 0 },
          showlegend: false,
        });
        traces.push({
          type: 'scatter', mode: 'lines', name: 'ask IV', x, y: askIv,
          line: { color: 'rgba(47,178,255,0.3)', width: 0 },
          fill: 'tonexty', fillcolor: 'rgba(47,178,255,0.12)',
          showlegend: false,
        });
      }

      traces.push({
        type: 'scatter', mode: 'markers', name: 'market', x, y: marketIv,
        marker: { color: '#d8e0ea', size: 4.5 },
      });
      traces.push({
        type: 'scatter', mode: 'lines', name: 'fitted', x, y: fittedIv,
        line: { color: '#19d8a8', width: 2 },
      });

      Plotly.react(div, traces, {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 40, r: 8, b: 30, t: 6 },
        xaxis: { title: 'ln(K/F)', ...axisStyle },
        yaxis: { title: 'IV (%)', ...axisStyle },
        legend: { orientation: 'h', y: 1.02, x: 0.01, font: { size: 9 } },
        transition: { duration: 120, easing: 'linear' },
      }, { responsive: true, displayModeBar: false });
    }

    function ensureExpirySelection() {
      const sel = panels.smile ? panels.smile.expirySelect : null;
      if (!sel) return;
      const expiries = calibratedSlices.map(s => s.expiryCode);
      const prev = activeExpiry;
      sel.innerHTML = '';
      for (const e of expiries) {
        const opt = document.createElement('option');
        opt.value = e; opt.textContent = e;
        sel.appendChild(opt);
      }
      if (expiries.length === 0) { activeExpiry = ''; return; }
      activeExpiry = (prev && expiries.includes(prev)) ? prev : expiries[0];
      sel.value = activeExpiry;
    }

    // --- Greeks Heatmap ---
    function renderGreeks(data) {
      const div = panels.greeks ? panels.greeks.chartDiv : null;
      if (!div || !data) return;

      const { z, sampledStrikes, expLabels } = data;

      const colorscales = {
        delta: [[0,'#0d2847'],[0.5,'#1a3a5c'],[1,'#2fb2ff']],
        gamma: [[0,'#0d2820'],[0.5,'#1a5c3a'],[1,'#19d8a8']],
        vega:  [[0,'#28200d'],[0.5,'#5c4a1a'],[1,'#ffb347']],
        theta: [[0,'#280d0d'],[0.5,'#5c1a1a'],[1,'#ff7a7a']],
      };

      Plotly.react(div, [{
        type: 'heatmap',
        x: sampledStrikes.map(s => pFmt.format(s)),
        y: expLabels, z,
        colorscale: colorscales[activeGreek] || colorscales.delta,
        showscale: true,
        colorbar: { title: activeGreek, titleside: 'right', thickness: 10, len: 0.6 },
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Term Structure ---
    function renderTerm(r) {
      const div = panels.term ? panels.term.chartDiv : null;
      if (!div || !r) return;
      if (calibratedSlices.length === 0) return;

      const expLabels = calibratedSlices.map(s => s.expiryLabel);
      const atmVols = calibratedSlices.map(s => s.atmVol);

      const traces = [{
        type: 'scatter', mode: 'lines+markers', name: 'ATM IV',
        x: expLabels, y: atmVols,
        line: { color: '#2fb2ff', width: 2 },
        marker: { color: '#2fb2ff', size: 5 },
      }];

      traces.push({
        type: 'scatter', mode: 'lines+markers', name: 'RR25',
        x: expLabels, y: r.termRr25, yaxis: 'y2',
        line: { color: '#ff7a7a', width: 1.5, dash: 'dot' },
        marker: { size: 4 },
      });
      traces.push({
        type: 'scatter', mode: 'lines+markers', name: 'BF25',
        x: expLabels, y: r.termBf25, yaxis: 'y2',
        line: { color: '#ffb347', width: 1.5, dash: 'dot' },
        marker: { size: 4 },
      });

      const rvol = r.realizedVol;
      if (isFinite(rvol) && rvol > 0) {
        traces.push({
          type: 'scatter', mode: 'lines', name: 'Realized',
          x: [expLabels[0], expLabels[expLabels.length - 1]], y: [rvol, rvol],
          line: { color: '#888', width: 1, dash: 'dash' },
        });
      }

      Plotly.react(div, traces, {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 40, r: 50, b: 30, t: 6 },
        xaxis: { title: '', ...axisStyle },
        yaxis: { title: 'ATM IV (%)', ...axisStyle },
        yaxis2: { title: 'RR/BF', ...axisStyle, overlaying: 'y', side: 'right' },
        legend: { orientation: 'h', y: 1.05, x: 0.01, font: { size: 9 } },
        showlegend: true,
        transition: { duration: 120, easing: 'linear' },
      }, { responsive: true, displayModeBar: false });
    }

    // --- Metrics & Skew Table ---
    function renderMetrics(r) {
      const p = panels.metrics;
      if (!p) return;

      if (p.mSpot) p.mSpot.textContent = spotPrice > 0 ? pFmt.format(spotPrice) : '--';
      if (p.mOptions) p.mOptions.textContent = chain.size || '--';
      if (p.mExpiries) p.mExpiries.textContent = calibratedSlices.length || '--';
      if (p.mTps) p.mTps.textContent = ticksPerSec > 0 ? pFmt1.format(ticksPerSec) : '--';
      if (p.mCalib) p.mCalib.textContent = calibTimeUs > 0 ? calibTimeUs.toString() : '--';

      const rvol = r ? r.realizedVol : NaN;
      if (p.mRvol) p.mRvol.textContent = isFinite(rvol) ? pFmt1.format(rvol) + '%' : '--';

      const tbody = p.skewTbody;
      if (!tbody || !r || !r.d25) return;
      tbody.innerHTML = '';

      const mD25 = r.d25;
      const mAtmIv = r.atmIv;

      for (let i = 0; i < calibratedSlices.length; i++) {
        const sl = calibratedSlices[i];
        const ivCall = mD25[i * 4 + 2];
        const ivPut = mD25[i * 4 + 3];
        const atmIv = mAtmIv[i];
        const rr25 = isFinite(ivCall) && isFinite(ivPut) ? (ivCall - ivPut) : NaN;
        const bf25 = isFinite(ivCall) && isFinite(ivPut) ? (0.5*(ivCall+ivPut) - atmIv) : NaN;

        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${sl.expiryLabel}</td>`
          + `<td>${pFmt1.format(sl.atmVol)}</td>`
          + `<td>${pFmt.format(sl.rmse)}</td>`
          + `<td>${sl.skew.toFixed(4)}</td>`
          + `<td>${sl.kurtProxy.toFixed(4)}</td>`
          + `<td>${isFinite(rr25) ? pFmt1.format(rr25) : '-'}</td>`
          + `<td>${isFinite(bf25) ? pFmt1.format(bf25) : '-'}</td>`
          + `<td>${sl.n}</td>`;
        tbody.appendChild(tr);
      }
    }

    // =====================================================================
    //  Mispricing Scanner
    // =====================================================================
    let edgeThreshold = 1.0;
    let edgeSideFilter = 'all';
    let minMaturity = 0; // minimum T in days (0 = no filter)

    // --- Scanner ---
    function renderScanner(data) {
      if (!data) return;
      const heatDiv = panels.scanner ? panels.scanner.heatmapDiv : null;
      const edgeTbody = panels.scanner ? panels.scanner.edgeTbody : null;
      if (!heatDiv || !edgeTbody) return;

      const { heatZ, heatText, sampledStrikes, expLabels, maxEdge, edges } = data;

      // Apply maturity filter to heatmap rows
      const minT = minMaturity / 365;
      let filteredExpLabels = expLabels, filteredHeatZ = heatZ, filteredHeatText = heatText;
      if (minT > 0 && data.sliceTValues) {
        const mask = data.sliceTValues.map(t => t >= minT);
        filteredExpLabels = expLabels.filter((_, i) => mask[i]);
        filteredHeatZ = heatZ.filter((_, i) => mask[i]);
        filteredHeatText = heatText.filter((_, i) => mask[i]);
      }

      Plotly.react(heatDiv, [{
        type: 'heatmap',
        x: sampledStrikes.map(s => pFmt.format(s)),
        y: filteredExpLabels,
        z: filteredHeatZ,
        text: filteredHeatText,
        hovertemplate: '%{text}<extra></extra>',
        colorscale: [
          [0, '#ff4444'],
          [0.35, '#cc2222'],
          [0.5, '#1a1a2e'],
          [0.65, '#118855'],
          [1, '#19d8a8'],
        ],
        zmin: -maxEdge, zmax: maxEdge,
        showscale: true,
        colorbar: {
          title: 'IV edge (vol pts)',
          titleside: 'right',
          thickness: 10,
          len: 0.8,
        },
      }], {
        ...darkLayout,
        uirevision: 'stable',
        margin: { l: 60, r: 50, b: 40, t: 6 },
        xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 },
        yaxis: { title: '', ...axisStyle },
      }, { responsive: true, displayModeBar: false });

      // Table
      const filtered = edges
        .filter(e => e.T >= minT)
        .filter(e => e.absIvEdge >= edgeThreshold)
        .filter(e => {
          if (edgeSideFilter === 'buy') return e.ivEdge > 0;
          if (edgeSideFilter === 'sell') return e.ivEdge < 0;
          return true;
        })
        .sort((a, b) => b.absIvEdge - a.absIvEdge)
        .slice(0, 40);

      edgeTbody.innerHTML = '';
      for (const e of filtered) {
        const isBuy = e.ivEdge > 0;
        const edgeCls = isBuy ? 'edge-buy' : 'edge-sell';
        const strongCls = e.absIvEdge >= edgeThreshold * 2 ? ' edge-strong' : '';
        const actionable = (isBuy && e.buySignal) || (!isBuy && e.sellSignal);
        const rowCls = actionable ? (isBuy ? 'edge-actionable' : 'edge-actionable sell') : '';
        const signal = e.buySignal ? 'BUY' : (e.sellSignal ? 'SELL' : '-');
        const signalCls = e.buySignal ? 'edge-buy edge-strong' : (e.sellSignal ? 'edge-sell edge-strong' : '');

        const tr = document.createElement('tr');
        if (rowCls) tr.className = rowCls;
        tr.innerHTML =
          `<td>${e.expiryCode}</td>`
          + `<td style="text-align:right">${pFmt.format(e.strike)}</td>`
          + `<td>${e.isCall ? 'C' : 'P'}</td>`
          + `<td style="text-align:right">${e.marketIvPct.toFixed(1)}</td>`
          + `<td style="text-align:right">${e.modelIvPct.toFixed(1)}</td>`
          + `<td style="text-align:right" class="${edgeCls}${strongCls}">${e.ivEdge > 0 ? '+' : ''}${e.ivEdge.toFixed(2)}</td>`
          + `<td style="text-align:right">${isFinite(e.bidPrice) ? pFmt.format(e.bidPrice) : '-'}</td>`
          + `<td style="text-align:right">${isFinite(e.askPrice) ? pFmt.format(e.askPrice) : '-'}</td>`
          + `<td style="text-align:right">${pFmt.format(e.marketMid)}</td>`
          + `<td style="text-align:right">${pFmt.format(e.theoPrice)}</td>`
          + `<td style="text-align:right" class="${edgeCls}">${e.dollarEdge > 0 ? '+' : ''}${pFmt.format(e.dollarEdge)}</td>`
          + `<td class="${signalCls}">${signal}</td>`;
        edgeTbody.appendChild(tr);
      }
    }

    // =====================================================================
    //  Forward Vol Panel
    // =====================================================================
    function renderForwardVol() {
      const p = panels.forwardvol;
      if (!p || !p.chartDiv || !lastForwardVolData) return;
      const d = lastForwardVolData;
      if (p.activeTab === 'term') {
        if (!d.labels || d.labels.length === 0) return;
        Plotly.react(p.chartDiv, [
          { type: 'scatter', mode: 'lines+markers', name: 'Forward Vol', x: d.labels, y: d.fwdVols, line: { color: '#ff7a7a', width: 2 }, marker: { size: 5 } },
          { type: 'scatter', mode: 'lines+markers', name: 'Spot Vol', x: d.labels, y: d.spotVols, line: { color: '#2fb2ff', width: 1.5, dash: 'dash' }, marker: { size: 4 } },
        ], {
          ...darkLayout, uirevision: 'fwd-term', margin: { l: 40, r: 8, b: 60, t: 6 },
          xaxis: { title: '', ...axisStyle, tickangle: -30 }, yaxis: { title: 'Vol (%)', ...axisStyle },
          legend: { orientation: 'h', y: 1.05, x: 0.01, font: { size: 9 } },
        }, { responsive: true, displayModeBar: false });
      } else {
        if (!d.skewTraces || d.skewTraces.length === 0) return;
        const traces = d.skewTraces.map(t => ({
          type: 'scatter', mode: 'lines+markers', name: t.label, x: t.kPoints, y: t.fwdSkew, marker: { size: 4 },
        }));
        Plotly.react(p.chartDiv, traces, {
          ...darkLayout, uirevision: 'fwd-skew', margin: { l: 40, r: 8, b: 30, t: 6 },
          xaxis: { title: 'ln(K/F)', ...axisStyle }, yaxis: { title: 'Fwd Vol (%)', ...axisStyle },
          legend: { orientation: 'h', y: 1.05, x: 0.01, font: { size: 8 } },
        }, { responsive: true, displayModeBar: false });
      }
    }

    // =====================================================================
    //  Funding & Basis Panel
    // =====================================================================
    async function fetchFundingHistory() {
      try {
        const perpInstrument = currencyConfig.prefix + 'PERPETUAL';
        const endTs = Date.now(), startTs = endTs - 7 * 24 * 60 * 60 * 1000;
        const resp = await fetch(`${DERIBIT_REST}/get_funding_rate_history?instrument_name=${perpInstrument}&start_timestamp=${startTs}&end_timestamp=${endTs}`);
        const data = await resp.json();
        if (data.result) {
          fundingState.history = data.result.map(r => ({ timestamp: r.timestamp, rate: r.interest_8h || 0 }));
          renderFunding();
        }
      } catch (e) { console.warn('[funding] fetch failed:', e); }
    }

    function renderFunding() {
      const p = panels.funding; if (!p || !p.chartDiv) return;
      if (p.fRate) p.fRate.textContent = isFinite(fundingState.currentRate) ? (fundingState.currentRate * 100).toFixed(4) + '%' : '--';
      if (p.fPerp) p.fPerp.textContent = isFinite(fundingState.perpPrice) ? pFmt.format(fundingState.perpPrice) : '--';
      if (p.fIndex) p.fIndex.textContent = isFinite(fundingState.indexPrice) ? pFmt.format(fundingState.indexPrice) : '--';
      if (p.activeTab === 'funding') {
        if (fundingState.history.length < 2) return;
        Plotly.react(p.chartDiv, [{
          type: 'scatter', mode: 'lines', name: '8h Funding Rate',
          x: fundingState.history.map(h => new Date(h.timestamp)), y: fundingState.history.map(h => h.rate * 100),
          line: { color: '#2fb2ff', width: 1.5 }, fill: 'tozeroy', fillcolor: 'rgba(47,178,255,0.1)',
        }], {
          ...darkLayout, uirevision: 'funding', margin: { l: 50, r: 8, b: 30, t: 6 },
          xaxis: { ...axisStyle, type: 'date' }, yaxis: { title: 'Rate (%)', ...axisStyle },
        }, { responsive: true, displayModeBar: false });
      } else if (p.activeTab === 'basis') {
        if (calibratedSlices.length === 0 || spotPrice <= 0) return;
        const labels = calibratedSlices.map(s => s.expiryLabel);
        const basis = calibratedSlices.map(s => s.forward - spotPrice);
        const basisPct = calibratedSlices.map(s => ((s.forward - spotPrice) / spotPrice) * 100);
        Plotly.react(p.chartDiv, [{
          type: 'bar', name: 'Basis ($)', x: labels, y: basis,
          marker: { color: basis.map(b => b >= 0 ? '#19d8a8' : '#ff7a7a') },
          text: basisPct.map(b => b.toFixed(2) + '%'), textposition: 'outside', textfont: { size: 9, color: '#8ea1b8' },
        }], {
          ...darkLayout, uirevision: 'basis', margin: { l: 50, r: 8, b: 30, t: 6 },
          xaxis: { ...axisStyle }, yaxis: { title: 'Basis ($)', ...axisStyle },
        }, { responsive: true, displayModeBar: false });
      } else if (p.activeTab === 'carry') {
        if (calibratedSlices.length === 0 || spotPrice <= 0) return;
        const dte = calibratedSlices.map(s => Math.round(s.T * 365));
        const carry = calibratedSlices.map(s => s.T > 0 ? ((s.forward / spotPrice - 1) / s.T) * 100 : 0);
        Plotly.react(p.chartDiv, [{
          type: 'scatter', mode: 'lines+markers', name: 'Annualized Carry',
          x: dte, y: carry, line: { color: '#ffb347', width: 2 }, marker: { size: 5 },
        }], {
          ...darkLayout, uirevision: 'carry', margin: { l: 50, r: 8, b: 30, t: 6 },
          xaxis: { title: 'DTE', ...axisStyle }, yaxis: { title: 'Carry (% ann.)', ...axisStyle },
        }, { responsive: true, displayModeBar: false });
      }
    }

    // =====================================================================
    //  Trade Flow Panel
    // =====================================================================
    function handleTradeMessage(data) {
      const trades = Array.isArray(data) ? data : [data];
      for (const t of trades) {
        if (!t.instrument_name) continue;
        if (currencyConfig.isLinear && !t.instrument_name.startsWith(currencyConfig.prefix)) continue;
        const parsed = parseInstrumentName(t.instrument_name);
        if (!parsed) continue;
        const iv = normalizeIv(t.iv || 0);
        const notional = (t.amount || 0) * (t.index_price || spotPrice || 0);
        const trade = {
          instrument: t.instrument_name, timestamp: t.timestamp || Date.now(),
          direction: t.direction || 'buy', amount: t.amount || 0, price: t.price || 0,
          iv, indexPrice: t.index_price || spotPrice, notional,
          strike: parsed.strike, expiry: parsed.expiry, isCall: parsed.isCall,
        };
        tradeFlow.tape.push(trade);
        if (tradeFlow.tape.length > 500) tradeFlow.tape.shift();
        const volKey = `${parsed.expiry}|${parsed.strike}|${parsed.isCall ? 'C' : 'P'}`;
        const ex = tradeFlow.sessionVolume.get(volKey) || { volume: 0, notional: 0, count: 0 };
        ex.volume += trade.amount; ex.notional += notional; ex.count++;
        tradeFlow.sessionVolume.set(volKey, ex);
        if (parsed.isCall) tradeFlow.callVolume += trade.amount;
        else tradeFlow.putVolume += trade.amount;
        tradeFlow.totalNotional += notional;
        tradeFlow.lastNotionals.push(notional);
        if (tradeFlow.lastNotionals.length > 100) tradeFlow.lastNotionals.shift();
        if (tradeFlow.lastNotionals.length >= 10) {
          const sorted = [...tradeFlow.lastNotionals].sort((a, b) => a - b);
          const median = sorted[Math.floor(sorted.length / 2)];
          if (notional > median * 5) {
            tradeFlow.largeTrades.push(trade);
            if (tradeFlow.largeTrades.length > 200) tradeFlow.largeTrades.shift();
          }
        }
        tradeFlowDirty = true;
      }
      if (tradeFlowDirty && !tradeFlowRafPending) {
        tradeFlowRafPending = true;
        setTimeout(() => { requestAnimationFrame(() => { renderTradeFlow(); tradeFlowDirty = false; tradeFlowRafPending = false; }); }, 500);
      }
    }

    function renderTradeFlow() {
      const p = panels.tradeflow; if (!p) return;
      const pcr = tradeFlow.putVolume > 0 ? (tradeFlow.callVolume / tradeFlow.putVolume).toFixed(2) : '--';
      if (p.tfPcr) p.tfPcr.textContent = pcr;
      if (p.tfVol) p.tfVol.textContent = (tradeFlow.callVolume + tradeFlow.putVolume).toLocaleString();
      if (p.tfNotional) p.tfNotional.textContent = '$' + pFmt.format(tradeFlow.totalNotional / 1000) + 'k';
      if (p.activeTab === 'tape') {
        if (!p.tapeTbody) return;
        p.tapeTbody.innerHTML = '';
        for (const t of tradeFlow.tape.slice(-50).reverse()) {
          const tr = document.createElement('tr');
          const cls = t.direction === 'buy' ? 'trade-buy' : 'trade-sell';
          tr.innerHTML = `<td>${new Date(t.timestamp).toLocaleTimeString()}</td><td>${t.instrument}</td>`
            + `<td class="${cls}">${t.direction}</td><td>${t.amount}</td>`
            + `<td>${pFmt.format(t.price)}</td><td>${isFinite(t.iv) ? (t.iv * 100).toFixed(1) + '%' : '--'}</td>`;
          p.tapeTbody.appendChild(tr);
        }
      } else if (p.activeTab === 'heatmap') {
        if (!p.heatmapDiv || tradeFlow.sessionVolume.size === 0) return;
        const expSet = new Set(), strikeSet = new Set();
        for (const [key] of tradeFlow.sessionVolume) { const [exp, strike] = key.split('|'); expSet.add(exp); strikeSet.add(parseFloat(strike)); }
        const expiries = [...expSet].sort(), strikes = [...strikeSet].sort((a, b) => a - b);
        const maxS = 25, step = strikes.length > maxS ? Math.ceil(strikes.length / maxS) : 1;
        const sampled = strikes.filter((_, i) => i % step === 0);
        const z = expiries.map(exp => sampled.map(strike => {
          const cVol = tradeFlow.sessionVolume.get(`${exp}|${strike}|C`)?.volume || 0;
          const pVol = tradeFlow.sessionVolume.get(`${exp}|${strike}|P`)?.volume || 0;
          return cVol + pVol;
        }));
        Plotly.react(p.heatmapDiv, [{
          type: 'heatmap', x: sampled.map(s => pFmt.format(s)), y: expiries, z,
          colorscale: [[0,'#0a0a1a'],[0.5,'#1a3a5c'],[1,'#2fb2ff']],
          showscale: true, colorbar: { title: 'volume', titleside: 'right', thickness: 10, len: 0.6 },
        }], {
          ...darkLayout, uirevision: 'tf-heat', margin: { l: 60, r: 50, b: 40, t: 6 },
          xaxis: { title: 'Strike', ...axisStyle, tickangle: -45 }, yaxis: { ...axisStyle },
        }, { responsive: true, displayModeBar: false });
      } else if (p.activeTab === 'large') {
        if (!p.largeTbody) return;
        p.largeTbody.innerHTML = '';
        for (const t of [...tradeFlow.largeTrades].reverse().slice(0, 50)) {
          const tr = document.createElement('tr');
          const cls = t.direction === 'buy' ? 'trade-buy' : 'trade-sell';
          tr.innerHTML = `<td>${new Date(t.timestamp).toLocaleTimeString()}</td><td>${t.instrument}</td>`
            + `<td class="${cls}">${t.direction}</td><td class="trade-large">${t.amount}</td>`
            + `<td>${pFmt.format(t.price)}</td><td>${isFinite(t.iv) ? (t.iv * 100).toFixed(1) + '%' : '--'}</td>`
            + `<td>$${pFmt.format(t.notional)}</td>`;
          p.largeTbody.appendChild(tr);
        }
      }
    }

    // =====================================================================
    //  Vol Cone & IV Rank Panel
    // =====================================================================
    async function fetchHistoricalVol() {
      try {
        const resp = await fetch(`${DERIBIT_REST}/get_historical_volatility?currency=${currencyConfig.base || currencyConfig.apiCurrency}`);
        const data = await resp.json();
        if (data.result) { historicalVolData = data.result; renderVolCone(); }
      } catch (e) { console.warn('[volcone] fetch failed:', e); }
    }

    function renderVolCone() {
      const p = panels.volcone; if (!p || !p.chartDiv) return;
      const frontAtm = calibratedSlices.length > 0 ? calibratedSlices[0].atmVol : NaN;
      if (p.vcAtmiv) p.vcAtmiv.textContent = isFinite(frontAtm) ? frontAtm.toFixed(1) + '%' : '--';
      // Use realizedVol from worker (computed via WASM log_returns_batch + realized_vol)
      const rvolPct = frameCache ? frameCache.realizedVol : NaN;
      if (p.vcRvol) p.vcRvol.textContent = isFinite(rvolPct) ? rvolPct.toFixed(1) + '%' : '--';
      if (!historicalVolData || historicalVolData.length < 10) return;
      const volSeries = historicalVolData
        .filter(d => Array.isArray(d) && d.length >= 2 && d[1] > 0)
        .map(d => ({ ts: d[0], vol: d[1] })).sort((a, b) => a.ts - b.ts);
      if (volSeries.length < 10) return;
      const windows = [10*24, 20*24, 30*24, 60*24, 90*24, 180*24, 252*24];
      const windowLabels = ['10d','20d','30d','60d','90d','180d','252d'];
      const cutoff = volSeries[volSeries.length-1].ts - volConeLookback * 24 * 3600 * 1000;
      const filtered = volSeries.filter(d => d.ts >= cutoff);
      const percentiles = [10,25,50,75,90];
      const bands = {}; for (const pc of percentiles) bands[pc] = [];
      const currentVols = [];
      for (const win of windows) {
        const vols = [];
        for (let i = win; i < filtered.length; i++) vols.push(filtered[i].vol);
        if (vols.length === 0) { for (const pc of percentiles) bands[pc].push(NaN); currentVols.push(NaN); continue; }
        vols.sort((a,b) => a - b);
        for (const pc of percentiles) bands[pc].push(vols[Math.floor((pc/100)*(vols.length-1))]);
        currentVols.push(vols[vols.length-1]);
      }
      if (isFinite(frontAtm) && filtered.length > 0) {
        const allVols = filtered.map(d => d.vol).sort((a,b) => a - b);
        const low = allVols[0], high = allVols[allVols.length-1];
        const ivRank = high > low ? ((frontAtm - low) / (high - low) * 100) : 50;
        const ivPctl = (allVols.filter(v => v < frontAtm).length / allVols.length) * 100;
        if (p.vcIvrank) p.vcIvrank.textContent = ivRank.toFixed(0) + '%';
        if (p.vcIvpctl) p.vcIvpctl.textContent = ivPctl.toFixed(0) + '%';
      }
      const traces = [
        { type:'scatter', mode:'lines', name:'90th', x:windowLabels, y:bands[90], line:{color:'rgba(47,178,255,0.3)',width:1} },
        { type:'scatter', mode:'lines', name:'75th', x:windowLabels, y:bands[75], line:{color:'rgba(47,178,255,0.4)',width:1}, fill:'tonexty', fillcolor:'rgba(47,178,255,0.08)' },
        { type:'scatter', mode:'lines', name:'50th', x:windowLabels, y:bands[50], line:{color:'rgba(47,178,255,0.5)',width:1.5}, fill:'tonexty', fillcolor:'rgba(47,178,255,0.12)' },
        { type:'scatter', mode:'lines', name:'25th', x:windowLabels, y:bands[25], line:{color:'rgba(47,178,255,0.4)',width:1}, fill:'tonexty', fillcolor:'rgba(47,178,255,0.12)' },
        { type:'scatter', mode:'lines', name:'10th', x:windowLabels, y:bands[10], line:{color:'rgba(47,178,255,0.3)',width:1}, fill:'tonexty', fillcolor:'rgba(47,178,255,0.08)' },
        { type:'scatter', mode:'lines+markers', name:'Current RVol', x:windowLabels, y:currentVols, line:{color:'#19d8a8',width:2.5}, marker:{size:6} },
      ];
      if (isFinite(frontAtm)) traces.push({ type:'scatter', mode:'lines', name:'ATM IV', x:[windowLabels[0],windowLabels[windowLabels.length-1]], y:[frontAtm,frontAtm], line:{color:'#ff7a7a',width:1.5,dash:'dash'} });
      Plotly.react(p.chartDiv, traces, {
        ...darkLayout, uirevision: 'volcone', margin: { l: 40, r: 8, b: 30, t: 6 },
        xaxis: { title: 'Window', ...axisStyle }, yaxis: { title: 'Vol (%)', ...axisStyle },
        legend: { orientation: 'h', y: 1.08, x: 0.01, font: { size: 8 } }, showlegend: true,
      }, { responsive: true, displayModeBar: false });
    }

    // =====================================================================
    //  Perpetual WS Handler
    // =====================================================================
    function handlePerpetualMessage(data) {
      if (!data) return;
      const d = Array.isArray(data) ? data[0] : data;
      if (d.funding !== undefined) fundingState.currentRate = d.funding;
      if (d.mark_price !== undefined) fundingState.perpPrice = d.mark_price;
      if (d.index_price !== undefined) fundingState.indexPrice = d.index_price;
      renderFunding();
    }

    // =====================================================================
    //  Strategy Builder
    // =====================================================================
    function addStrategyLeg() {
      const atm = spotPrice > 0 ? Math.round(spotPrice / 1000) * 1000 : 50000;
      const frontExp = calibratedSlices.length > 0 ? calibratedSlices[0] : null;
      const iv = frontExp ? frontExp.atmVol / 100 : 0.5;
      const T = frontExp ? frontExp.T : 30 / 365;
      strategyLegs.push({ strike: atm, expiry: frontExp ? frontExp.expiryCode : '30D', isCall: true, quantity: 1, iv, T });
      renderStrategyLegs(); triggerStrategyCompute();
    }

    function applyStrategyTemplate(tmpl) {
      strategyLegs.length = 0;
      const atm = spotPrice > 0 ? Math.round(spotPrice / 1000) * 1000 : 50000;
      const frontExp = calibratedSlices.length > 0 ? calibratedSlices[0] : null;
      const iv = frontExp ? frontExp.atmVol / 100 : 0.5;
      const T = frontExp ? frontExp.T : 30 / 365;
      const exp = frontExp ? frontExp.expiryCode : '30D';
      const step = Math.round(atm * 0.05 / 1000) * 1000 || 1000;
      const leg = (s, c, q) => ({ strike: s, expiry: exp, isCall: c, quantity: q, iv, T });
      switch (tmpl) {
        case 'straddle': strategyLegs.push(leg(atm,true,1), leg(atm,false,1)); break;
        case 'strangle': strategyLegs.push(leg(atm+step,true,1), leg(atm-step,false,1)); break;
        case 'bull-call': strategyLegs.push(leg(atm,true,1), leg(atm+step*2,true,-1)); break;
        case 'bear-put': strategyLegs.push(leg(atm,false,1), leg(atm-step*2,false,-1)); break;
        case 'iron-condor': strategyLegs.push(leg(atm-step*2,false,1), leg(atm-step,false,-1), leg(atm+step,true,-1), leg(atm+step*2,true,1)); break;
        case 'butterfly': strategyLegs.push(leg(atm-step,true,1), leg(atm,true,-2), leg(atm+step,true,1)); break;
      }
      renderStrategyLegs(); triggerStrategyCompute();
    }

    function renderStrategyLegs() {
      const p = panels.strategy; if (!p || !p.legsTbody) return;
      p.legsTbody.innerHTML = '';
      for (let i = 0; i < strategyLegs.length; i++) {
        const l = strategyLegs[i], tr = document.createElement('tr');
        tr.innerHTML = `<td>${l.isCall?'C':'P'}</td>`
          + `<td><input type="number" value="${l.strike}" style="width:70px;background:#0d141d;color:var(--fg);border:1px solid var(--border);font-size:10px;font-family:var(--mono)" data-idx="${i}" data-field="strike"></td>`
          + `<td>${l.expiry}</td>`
          + `<td><input type="number" value="${l.quantity}" style="width:40px;background:#0d141d;color:var(--fg);border:1px solid var(--border);font-size:10px;font-family:var(--mono)" data-idx="${i}" data-field="quantity"></td>`
          + `<td>${(l.iv*100).toFixed(1)}%</td><td>--</td>`
          + `<td><button class="tab-btn" data-remove="${i}" style="font-size:9px;padding:0 4px;color:var(--danger)">x</button></td>`;
        p.legsTbody.appendChild(tr);
      }
      p.legsTbody.querySelectorAll('input').forEach(inp => {
        inp.addEventListener('change', (e) => {
          const idx = parseInt(e.target.dataset.idx), field = e.target.dataset.field;
          if (field === 'strike') strategyLegs[idx].strike = parseFloat(e.target.value);
          if (field === 'quantity') strategyLegs[idx].quantity = parseInt(e.target.value);
          triggerStrategyCompute();
        });
      });
      p.legsTbody.querySelectorAll('[data-remove]').forEach(btn => {
        btn.addEventListener('click', (e) => { strategyLegs.splice(parseInt(e.target.dataset.remove), 1); renderStrategyLegs(); triggerStrategyCompute(); });
      });
    }

    function triggerStrategyCompute() {
      if (!workerReady || strategyLegs.length === 0) { renderStrategyPayoff(null); return; }
      const p = panels.strategy;
      const spotShock = p ? parseInt(p.slSpot.value) / 100 : 0;
      const volShock = p ? parseInt(p.slVol.value) / 100 : 0;
      const timeShock = p ? parseInt(p.slTime.value) / 365 : 0;
      computeWorker.postMessage({ type: 'strategy-compute', payload: { legs: strategyLegs.map(l => ({...l})), spotPrice, spotShock, volShock, timeShock } });
    }

    function renderStrategyPayoff(data) {
      const p = panels.strategy; if (!p || !p.chartDiv) return;
      if (!data) {
        Plotly.react(p.chartDiv, [], { ...darkLayout, uirevision: 'strat', margin: { l: 40, r: 8, b: 30, t: 6 },
          xaxis: { title: 'Spot', ...axisStyle }, yaxis: { title: 'P&L', ...axisStyle } }, { responsive: true, displayModeBar: false });
        return;
      }
      const { spotAxis, pnlAtExpiry, pnlBeforeExpiry, netGreeks, totalCost } = data;
      if (p.sgDelta) p.sgDelta.textContent = isFinite(netGreeks?.[0]) ? netGreeks[0].toFixed(4) : '--';
      if (p.sgGamma) p.sgGamma.textContent = isFinite(netGreeks?.[1]) ? netGreeks[1].toFixed(6) : '--';
      if (p.sgVega) p.sgVega.textContent = isFinite(netGreeks?.[2]) ? netGreeks[2].toFixed(2) : '--';
      if (p.sgTheta) p.sgTheta.textContent = isFinite(netGreeks?.[3]) ? netGreeks[3].toFixed(2) : '--';
      const traces = [{
        type: 'scatter', mode: 'lines', name: 'P&L at Expiry', x: spotAxis, y: pnlAtExpiry,
        line: { color: '#2fb2ff', width: 2 }, fill: 'tozeroy', fillcolor: 'rgba(47,178,255,0.08)',
      }];
      if (pnlBeforeExpiry) traces.push({ type: 'scatter', mode: 'lines', name: 'P&L (shocked)', x: spotAxis, y: pnlBeforeExpiry, line: { color: '#19d8a8', width: 1.5, dash: 'dash' } });
      if (spotPrice > 0) traces.push({ type: 'scatter', mode: 'lines', name: 'Current Spot', x: [spotPrice, spotPrice],
        y: [Math.min(...pnlAtExpiry, 0), Math.max(...pnlAtExpiry, 0)], line: { color: '#8ea1b8', width: 1, dash: 'dot' }, showlegend: false });
      Plotly.react(p.chartDiv, traces, {
        ...darkLayout, uirevision: 'strat', margin: { l: 50, r: 8, b: 30, t: 6 },
        xaxis: { title: 'Spot Price', ...axisStyle }, yaxis: { title: 'P&L ($)', ...axisStyle },
        legend: { orientation: 'h', y: 1.05, x: 0.01, font: { size: 9 } },
        shapes: [{ type: 'line', y0: 0, y1: 0, x0: spotAxis[0], x1: spotAxis[spotAxis.length-1], line: { color: '#3a4a5a', width: 1 } }],
      }, { responsive: true, displayModeBar: false });
    }

    // =====================================================================
    //  View Switching
    // =====================================================================
    function switchView(viewName) {
      if (viewName === activeView) return;
      if (!VIEW_DEFS[viewName]) return;

      // Save current layout to per-view localStorage key
      try {
        const key = activeView === 'all' ? LAYOUT_KEY : (LAYOUT_KEY_PREFIX + activeView);
        localStorage.setItem(key, JSON.stringify(dockview.toJSON()));
      } catch (e) { /* localStorage may be full */ }

      // Purge all Plotly charts to prevent memory leaks
      for (const key of Object.keys(panels)) {
        const p = panels[key];
        if (p && p.chartDiv) Plotly.purge(p.chartDiv);
        if (p && p.heatDiv) Plotly.purge(p.heatDiv);
        if (p && p.heatmapDiv) Plotly.purge(p.heatmapDiv);
      }

      // Reset surface zoom state
      surfaceInitialized = false;
      zoomTarget = null;
      zoomCurrent = null;
      if (zoomRafId) { cancelAnimationFrame(zoomRafId); zoomRafId = null; }

      // Clear all panels (triggers dispose() on each)
      dockview.clear();

      activeView = viewName;

      // Try to restore saved layout for this view, fall back to default
      const savedKey = viewName === 'all' ? LAYOUT_KEY : (LAYOUT_KEY_PREFIX + viewName);
      const saved = localStorage.getItem(savedKey);
      if (saved) {
        try {
          dockview.fromJSON(JSON.parse(saved));
        } catch (e) {
          applyViewDef(viewName);
        }
      } else {
        applyViewDef(viewName);
      }

      // Update button active states
      document.querySelectorAll('.view-switcher .tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewName);
      });

      // Re-render all active panels with cached data on next frame
      requestAnimationFrame(() => {
        if (lastSurfaceData && panels.surface) renderSurface(lastSurfaceData);
        if (lastGreeksData && panels.greeks) renderGreeks(lastGreeksData);
        if (lastScannerData && panels.scanner) renderScanner(lastScannerData);
        if (lastForwardVolData && panels.forwardvol) renderForwardVol();
        if (panels.term && frameCache) renderTerm(frameCache);
        if (panels.smile) renderSmile();
        if (panels.volchange) renderVolChange();
        if (panels.metrics && frameCache) renderMetrics(frameCache);
        if (panels.funding) renderFunding();
        if (panels.volcone) renderVolCone();
        if (panels.tradeflow) renderTradeFlow();
        if (lastStrategyResult && panels.strategy) renderStrategyPayoff(lastStrategyResult);
      });
    }

    function applyViewDef(viewName) {
      const def = VIEW_DEFS[viewName];
      if (!def) return;
      if (viewName === 'all' || !def.build) {
        createDefaultLayout(dockview);
      } else {
        def.build(dockview);
      }
    }

    // =====================================================================
    //  Deribit Connection (REST seed + WebSocket stream)
    // =====================================================================
    const DERIBIT_REST = 'https://www.deribit.com/api/v2/public';
    const DERIBIT_WS = 'wss://www.deribit.com/ws/api/v2';

    const statusPill = document.getElementById('status-pill');
    function setStatus(state, text) {
      statusPill.className = 'status-pill ' + state;
      statusPill.textContent = text;
    }

    async function seedFromRest() {
      try {
        setStatus('connecting', 'seeding...');
        const seedCurrency = activeCurrency; // capture for stale-check after await

        const [bookResp, indexResp] = await Promise.all([
          fetch(`${DERIBIT_REST}/get_book_summary_by_currency?currency=${currencyConfig.apiCurrency}&kind=option`),
          fetch(`${DERIBIT_REST}/get_index_price?index_name=${currencyConfig.indexName}`),
        ]);

        // Currency changed while we were fetching — discard stale response
        if (activeCurrency !== seedCurrency) return;

        const bookData = await bookResp.json();
        const indexData = await indexResp.json();

        if (indexData.result && indexData.result.index_price) {
          spotPrice = indexData.result.index_price;
        }

        const entries = bookData.result || [];
        let count = 0;
        for (const entry of entries) {
          const name = entry.instrument_name;
          if (!name) continue;
          // For USDC currencies, filter to matching base (e.g. only SOL_USDC-* for SOL_USDC)
          if (currencyConfig.isLinear && !name.startsWith(currencyConfig.prefix)) continue;
          const parsed = parseInstrumentName(name);
          if (!parsed) continue;

          const markIv = normalizeIv(entry.mark_iv || entry.iv || 0);
          if (isNaN(markIv) || markIv <= 0) continue;

          const underlying = (entry.underlying_price || entry.index_price || spotPrice);
          noteQuote(name, {
            strike: parsed.strike,
            expiryCode: parsed.expiry,
            expiryDate: parsed.expiryDate,
            isCall: parsed.isCall,
            mark_price: Math.max(entry.mark_price || 0, 0),
            mark_iv: markIv,
            underlying_price: underlying > 0 ? underlying : spotPrice,
            bid_iv: normalizeIv(entry.bid_iv || 0) || 0,
            ask_iv: normalizeIv(entry.ask_iv || 0) || 0,
            open_interest: Math.max(entry.open_interest || 0, 0),
          });
          count++;
        }
        console.log(`[rest] seeded ${count} options, spot=${spotPrice}`);
        scheduleCalibration();
      } catch (e) {
        console.error('[rest] seed failed:', e);
      }
    }

    function connectWs() {
      setStatus('connecting', 'connecting...');
      intentionalClose = false;
      const activeChannel = `markprice.options.${currencyConfig.indexName}`;
      const perpInstrument = currencyConfig.prefix + 'PERPETUAL';
      const tradeChannel = `trades.option.${currencyConfig.apiCurrency}.100ms`;
      const perpChannel = `perpetual.${perpInstrument}.100ms`;
      const ws = new WebSocket(DERIBIT_WS);
      activeWs = ws;

      ws.onopen = () => {
        setStatus('connected', 'live');
        // Subscribe to critical markprice channel first (must succeed)
        ws.send(JSON.stringify({
          jsonrpc: '2.0', id: 1,
          method: 'public/subscribe',
          params: { channels: [activeChannel] },
        }));
        // Subscribe to trade flow + perpetual channels separately (best-effort)
        ws.send(JSON.stringify({
          jsonrpc: '2.0', id: 2,
          method: 'public/subscribe',
          params: { channels: [tradeChannel, perpChannel] },
        }));
      };

      ws.onmessage = (event) => {
        try {
          if (ws !== activeWs) return; // stale WS from previous currency
          const msg = JSON.parse(event.data);
          if (!msg.params || !msg.params.data) return;
          const channel = msg.params.channel || '';

          // Route trade flow messages
          if (channel.startsWith('trades.')) { handleTradeMessage(msg.params.data); return; }
          // Route perpetual messages
          if (channel.startsWith('perpetual.')) { handlePerpetualMessage(msg.params.data); return; }

          if (channel !== activeChannel) return;

          const data = msg.params.data;
          const nodes = Array.isArray(data) ? data : [data];

          // Collect nested quote nodes
          const quoteNodes = [];
          function collect(val) {
            if (Array.isArray(val)) { val.forEach(collect); return; }
            if (val && typeof val === 'object') {
              if (val.instrument_name) { quoteNodes.push(val); return; }
              for (const v of Object.values(val)) {
                if (typeof v === 'object') collect(v);
              }
            }
          }
          collect(nodes);

          let anyUpdate = false;
          for (const node of quoteNodes) {
            const name = node.instrument_name || node.instrument;
            if (!name) continue;
            if (currencyConfig.isLinear && !name.startsWith(currencyConfig.prefix)) continue;
            const parsed = parseInstrumentName(name);
            if (!parsed) continue;

            const markIv = normalizeIv(node.mark_iv || node.iv || 0);
            const underlying = node.underlying_price || node.index_price;
            if (underlying && underlying > 0) spotPrice = underlying;

            const existing = chain.get(name);
            if (markIv > 0 || existing) {
              const q = existing || {
                strike: parsed.strike,
                expiryCode: parsed.expiry,
                expiryDate: parsed.expiryDate,
                isCall: parsed.isCall,
                mark_price: 0,
                mark_iv: 0,
                underlying_price: spotPrice,
                bid_iv: 0,
                ask_iv: 0,
                open_interest: 0,
              };
              if (markIv > 0) q.mark_iv = markIv;
              if (node.mark_price !== undefined) q.mark_price = Math.max(node.mark_price, 0);
              if (underlying > 0) q.underlying_price = underlying;
              const bidIv = normalizeIv(node.bid_iv || 0);
              if (bidIv > 0) q.bid_iv = bidIv;
              const askIv = normalizeIv(node.ask_iv || 0);
              if (askIv > 0) q.ask_iv = askIv;
              if (node.open_interest !== undefined) q.open_interest = Math.max(node.open_interest, 0);

              chain.set(name, q);
              dirty = true;
              tickCount++;
              anyUpdate = true;
            }
          }

          if (anyUpdate) scheduleCalibration();
        } catch (e) {
          // ignore parse errors
        }
      };

      ws.onerror = () => {
        setStatus('disconnected', 'ws error');
      };

      ws.onclose = () => {
        if (intentionalClose) return; // currency switch — don't auto-reconnect
        setStatus('disconnected', 'reconnecting...');
        setTimeout(connectWs, 2000);
      };
    }

    // =====================================================================
    //  Dockview Initialization
    // =====================================================================
    const LAYOUT_KEY = 'vol-terminal-layout';

    function createDefaultLayout(dv) {
      const surface = dv.addPanel({ id: 'surface', component: 'surface', title: '3D Vol Surface' });
      dv.addPanel({ id: 'volchange', component: 'volchange', title: 'IV Change Heatmap',
        position: { referencePanel: 'surface', direction: 'right' } });
      dv.addPanel({ id: 'smile', component: 'smile', title: 'Smile Slice',
        position: { referencePanel: 'surface', direction: 'below' } });
      dv.addPanel({ id: 'greeks', component: 'greeks', title: 'Greeks Heatmap',
        position: { referencePanel: 'volchange', direction: 'below' } });
      dv.addPanel({ id: 'term', component: 'term', title: 'Term Structure',
        position: { referencePanel: 'smile', direction: 'below' } });
      // Forward Vol tabbed with Term Structure
      dv.addPanel({ id: 'forwardvol', component: 'forwardvol', title: 'Forward Vol',
        position: { referencePanel: 'term' } });
      dv.addPanel({ id: 'metrics', component: 'metrics', title: 'Metrics & Skew',
        position: { referencePanel: 'greeks', direction: 'below' } });
      // Funding and Vol Cone tabbed with Metrics
      dv.addPanel({ id: 'funding', component: 'funding', title: 'Funding & Basis',
        position: { referencePanel: 'metrics' } });
      dv.addPanel({ id: 'volcone', component: 'volcone', title: 'Vol Cone',
        position: { referencePanel: 'metrics' } });
      dv.addPanel({ id: 'scanner', component: 'scanner', title: 'Mispricing Scanner',
        position: { referencePanel: 'term', direction: 'below' } });
      // Trade Flow and Strategy tabbed with Scanner
      dv.addPanel({ id: 'tradeflow', component: 'tradeflow', title: 'Trade Flow',
        position: { referencePanel: 'scanner' } });
      dv.addPanel({ id: 'strategy', component: 'strategy', title: 'Strategy Builder',
        position: { referencePanel: 'scanner' } });
    }

    const dockviewContainer = document.getElementById('dockview');
    const dockview = new DockviewComponent(dockviewContainer, {
      createComponent(options) {
        switch (options.name) {
          case 'surface': return new SurfacePanel();
          case 'volchange': return new VolChangePanel();
          case 'smile': return new SmilePanel();
          case 'greeks': return new GreeksPanel();
          case 'term': return new TermPanel();
          case 'metrics': return new MetricsPanel();
          case 'scanner': return new ScannerPanel();
          case 'forwardvol': return new ForwardVolPanel();
          case 'funding': return new FundingBasisPanel();
          case 'tradeflow': return new TradeFlowPanel();
          case 'volcone': return new VolConePanel();
          case 'strategy': return new StrategyPanel();
          default: {
            const el = document.createElement('div');
            el.className = 'dock-content';
            el.textContent = 'Unknown panel: ' + options.name;
            return { element: el, init() {}, dispose() {} };
          }
        }
      }
    });

    // Try to restore saved layout for active view, fall back to default
    {
      const savedKey = LAYOUT_KEY_PREFIX + activeView;
      const savedLayout = localStorage.getItem(savedKey);
      if (savedLayout) {
        try {
          dockview.fromJSON(JSON.parse(savedLayout));
          console.log('[dockview] restored ' + activeView + ' layout from localStorage');
        } catch (e) {
          console.warn('[dockview] failed to restore layout, using default:', e);
          applyViewDef(activeView);
        }
      } else {
        applyViewDef(activeView);
      }
    }

    // Persist layout changes (debounced, per-view key)
    let layoutSaveTimer = null;
    dockview.onDidLayoutChange(() => {
      clearTimeout(layoutSaveTimer);
      layoutSaveTimer = setTimeout(() => {
        try {
          const key = activeView === 'all' ? LAYOUT_KEY : (LAYOUT_KEY_PREFIX + activeView);
          localStorage.setItem(key, JSON.stringify(dockview.toJSON()));
        } catch (e) {
          // localStorage might be full or unavailable
        }
      }, 500);
    });

    // View switcher click handler
    document.querySelector('.view-switcher').addEventListener('click', (e) => {
      const btn = e.target.closest('.tab-btn');
      if (!btn || !btn.dataset.view) return;
      switchView(btn.dataset.view);
    });

    // Reset Layout button
    document.getElementById('reset-layout').addEventListener('click', () => {
      localStorage.removeItem(LAYOUT_KEY);
      for (const v of Object.keys(VIEW_DEFS)) {
        localStorage.removeItem(LAYOUT_KEY_PREFIX + v);
      }
      window.location.reload();
    });

    // =====================================================================
    //  Bootstrap
    // =====================================================================
    (async () => {
      await workerReadyPromise;
      console.log('[boot] worker ready');

      // Initialize IndexedDB + prune old data
      terminalDb.open().then(() => { terminalDb.pruneAll(); setInterval(() => terminalDb.pruneAll(), 3600000); }).catch(() => {});

      await seedFromRest();
      connectWs();
      fetchFundingHistory();
      fetchHistoricalVol();

      // Deferred GPU MC test — loads WASM on main thread just for WebGPU
      setTimeout(async () => {
        if (!navigator.gpu) { console.log('[gpu-mc] WebGPU not available'); return; }
        try {
          const mod = await import('./pkg/openferric_wasm.js');
          await mod.default();
          if (typeof mod.gpu_mc_price_european !== 'function') return;
          const mc = await mod.gpu_mc_price_european(
            100, 100, 0.05, 0.2, 1.0, 65536, 252, 42, true
          );
          console.log('[gpu-mc] price:', mc.price, 'stderr:', mc.stderr);
        } catch (gpuErr) {
          console.warn('[gpu-mc] WebGPU MC failed:', gpuErr.message || gpuErr);
        }
      }, 2000);
    })();
  </script>
</body>
</html>
